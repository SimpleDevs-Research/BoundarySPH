// === VARIABLES ===
uint numParticles;

// === STRUCTS ===
struct Particle {
    float3 position;            // The world position of the particle
    float3 force;               // The force current experienced by the particle that is caused by pressure and viscosity
    int render;
};

// === INPUT BUFFERS ===
StructuredBuffer<Particle> particles;
StructuredBuffer<float3> particle_velocities;
// === OUTPUT BUFFERS ===
RWStructuredBuffer<float3> particle_positions;
//RWStructuredBuffer<int> particle_velocities_hashed;

// === HELPER FUNCTIONS ===
int EncodeFloat3ToInt(float3 v) {
    //Vectors must stay within the -512 to 512 range per axis - no error handling coded here
    //Add 512 to get numbers into the 0-1024 range rather than -512 to 512 range
    //Multiply by 10 to save one decimal place from rounding
    int xcomp = int(v.x * 10) + 512;
    int ycomp = int(v.y * 10) + 512;
    int zcomp = int(v.z * 10) + 512;
    return xcomp + ycomp * 1024 + zcomp * 1048576;
}
float3 DecodeFloat3FromInt(int i) {
    //Get the leftmost bits first. The fractional remains are the bits to the right.
    // 1024 is 2 ^ 10 - 1048576 is 2 ^ 20 - just saving some calculation time doing that in advance
    float z = floor(float(i / 1048576));
    float y = floor (float((i - z * 1048576) / 1024));
    float x = float(i - y * 1024 - z * 1048576);
    // subtract 512 to move numbers back into the -512 to 512 range rather than 0 - 1024
    return float3(
        (x - 512) / 10, 
        (y - 512) / 10, 
        (z - 512) / 10
    );
}

#pragma kernel CondenseParticleData
[numthreads(64,1,1)]
void CondenseParticleData(uint id : SV_DispatchThreadID) {
    if (id >= numParticles) return;
    particle_positions[id] = particles[id].position;
    //particle_velocities_hashed[id] = EncodeFloat3ToInt(particle_velocities[id]);
}