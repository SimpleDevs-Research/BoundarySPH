// == WORLD CONFIGURATIONS ==
float gridCellSize;             // How big are our grid cells? For Prefix Summation, recommended to match `smoothingRadius`
float3 origin;                  // Where in world space are we centering the simulation around?
int3 numCellsPerAxis;           // Given `outerBounds`, how many grid cells are along each axis?
uint total_number_of_cells;     // How many grid cells do we have in total?
float3 g;                       // What's the gravitational force exerted on all particles?
float epsilon;                  // Mathf.epsilon
float pi;                       // Mathf.PI
float3 gridScaling;

// == PARTICLE CONFIGURATIONS ==
uint numParticles;              // How many particles will we use in the simulation?
//uint numBoids;                  // How many boids are a part of the simulation?
float particleRenderRadius;     // How big (visually only!) are each particle? For CubeVolume method, this is pretty important
// NEEDS TO BE INCORPORATED
uint numParticlesPerGridCell;   // How many particles can we realistically fit into each grid cell? Calculated from particle render size.
uint3 numParticlesPerAxis;

// == FLUID MECHANICS ==
float dt;                       // delta time - The time difference between frames.
float smoothingRadius;          // `h`: the smoothing kernel radius for SPH. For Prefix Sum, recommended to set to the same as `gridCellSize`.
float radius2;
float radius3;
//float radius4;
//float radius5;
float radius6;
//float radius8;
float radius9;
//float radius16;
float particleMass;             // How much mass does each particle have?
float viscosity_coefficient;    // The viscosity coefficient for SPH. The higher the value, the more particles are likely to clump together.
float rest_density;             // The density of the fluid at the ideal state
float damping;                  // The amount of influence that boundaries have on particles when particles collide with boundaries.
float gas_constant;             // The gas constant of the particle liquid. The higher this value, the more particles vibrate and launch themselves in the air. Depends on temperature in the real world.
float bulkModulus;

// GPU SETTINGS 
#define _BLOCK_SIZE 512        // How many threads can a thread group have?
int processType;                // What kind of neighbor search and parsing should we use? 0 = Prefix Sum, 1 = CubeVolume
uint numBlocks;                 // number of thread groups that run on the GPU

// == MISC VARIABLES ==
uint d;
int randomSeed;
int state;

// == STRUCTS ==
struct Particle {
    float3 position;
};
struct CellLimits {
    uint3 id;
    uint3 lowerLimits;
    uint3 upperLimits;
};
/*
struct Boid {
    float3 position;
    int3 gridIndices;
    int projectedGridIndex;
};
*/

// == BUFFERS ==
// Stores how many particles are inside each grid cell. 
    // Length = numGridCells
    // To get grid cell count: 
    //  1) Find projected grid cell hash index
    //  2) grid[projected_index] <- the # of particles in that grid cell.
RWStructuredBuffer<uint> grid;
// Stores the limits of each grid cell, in terms of neighbors. Same size as `grid`
RWStructuredBuffer<CellLimits> cellLimits;
// Stores all particle data in the system. 
    // Length = numParticles
RWStructuredBuffer<Particle> particles;
// Stores all boid data in the other manager.
//RWStructuredBuffer<Boid> boids;
//RWStructuredBuffer<float3> boidVelocities;
// Stores the "offsets" of each particle.
    // Length = numParticles
    // For example, each grid cell has `n` number of particles; `offset` is the index of the particle in their grid cell (max: `n-1`)
RWStructuredBuffer<uint> particleOffsets;
// Stores ID of particles in each grid cell. Length = numGridCells * numParticlesPerGridCell
    // To iterate through neighbors of a particle's current cell:
    //  1) Get neighbor cells' projected indices. Can be done by getting current cell's XYZ indices, then iterating through 27 neighbor cells
    //  2) Iterate through neighbor cells. For each neighbor cell:
    //      2a) Get their starting index `j` for particleNeighborBuffer (neighbor's hashed index * numParticlesPerGridCell)
    //      2b) Get # of neighbors `n` in that neighbor cell (gridBuffer[<neighbor's hashed index>])
    //      2c) Loop `i` through `j` to `j+(n-1)`. Neighbor ID = particleNeighborBuffer[i]
RWStructuredBuffer<uint> particleNeighbors;
RWStructuredBuffer<float> bounds;   // What are the limits of this simulation, in world space?

//neighbors of a particle at particle_index * max_particles_per_grid * 8  
RWStructuredBuffer<int> neighbor_tracker;       // RWStructuredBuffer<int> _neighbourTracker;    -- VERIFIED
// number of neighors does each particle have
RWStructuredBuffer<uint> hash_grid;             // RWStructuredBuffer<uint> _hashGrid;          -- VERIFIED
// aligned at particle_index * max_particles_per_grid * 8' + hash_grid_tracker[particle_index]
RWStructuredBuffer<uint> hash_grid_tracker;     // RWStructuredBuffer<uint> _hashGridTracker;   -- VERIFIED
// number of particles at each grid

// Stores the density of each particle
RWStructuredBuffer<float> density;
// Stores the pressure of each particle
//RWStructuredBuffer<float> pressure;
// Stores the velocity of each particle
RWStructuredBuffer<float3> velocity;
// Stores the pressure force of each particle
RWStructuredBuffer<float3> pressureForces;
// Stores the viscosity force of each particle
RWStructuredBuffer<float3> viscosityForces;
// Stores the force (acceleration) of each particle
RWStructuredBuffer<float3> force;
// Temp buffer for debugging
RWStructuredBuffer<int> temp_buffer;

// == HELPER FUNCTIONS ==
// Given a world space position, what are the XYZ indices of the position's current cell?
int3 GetGridXYZIndices(float3 position) {
    return int3(
        floor((position[0] - gridScaling[0])/gridCellSize),
        floor((position[1] - gridScaling[1])/gridCellSize),
        floor((position[2] - gridScaling[2])/gridCellSize)
    );
}
// Given an XYZ grid index, what is the projected 1D index?
int GetProjectedGridIndexFromXYZ(int3 xyz) {
    return xyz.x + (numCellsPerAxis[0] * xyz.y) + (numCellsPerAxis[0] * numCellsPerAxis[1] * xyz.z);
}
int GetProjectedGridIndexFromXYZ(int x, int y, int z) {
    return x + (numCellsPerAxis[0] * y) + (numCellsPerAxis[0] * numCellsPerAxis[1] * z);
}
uint GetProjectedGridIndexFromXYZ(uint x, uint y, uint z) {
    return x + (uint(numCellsPerAxis[0]) * y) + (uint(numCellsPerAxis[0]) * uint(numCellsPerAxis[1]) * z);
}
// Given a world space position, what is the projected 1D index of the position's current cell?
int GetProjectedGridIndexFromGivenPosition(float3 position) {
    int3 xyz = GetGridXYZIndices(position);
    return GetProjectedGridIndexFromXYZ(xyz);
}
// Given a projected hash, return that hash's position in the `particleNeighbors` buffer
int GetParticleNeighborStartingIndex(int projected_index) {
   return projected_index * numParticlesPerGridCell;
}
// Given XYZ coordinates, return the projected 1D indexes of all neighbor cells
void GetNeighborCellProjectedIDs(int3 currentCellXYZ, out int neighborCells[27]) {
    int result[27];
    int count = 0;
    for (int x = max(currentCellXYZ[0]-1,0); x <= min(currentCellXYZ[0]+1,numCellsPerAxis[0]-1); x++) {
        for (int y = max(currentCellXYZ[1]-1,0); y <= min(currentCellXYZ[1]+1,numCellsPerAxis[1]-1); y++) {
            for (int z = max(currentCellXYZ[2]-1,0); z <= min(currentCellXYZ[2]+1,numCellsPerAxis[2]-1); z++) {
                result[count] = GetProjectedGridIndexFromXYZ(int3(x,y,z));
                count += 1;
            }
        }
    }
    for(int c = count; c < 27; c++) result[c] = -1;
    neighborCells = result;
}
// Basic random generation
float wangHash() {
  state = (state ^ 61) ^(state >> 16);
  state *= 9;
  state = state ^(state >> 4);
  state *= 0x27d4eb2d;
  state = state ^(state >> 15);
  return state / 4294967296.0;
}
float randRange(float a, float b) {
  return wangHash() * (b - a) + a;
}

// == CORE METHODS

#pragma kernel GenerateParticles
[numthreads(_BLOCK_SIZE, 1, 1)]
// Generate particles. Better done in the GPU than the CPU.
void GenerateParticles(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numParticles) return;
    //state = randomSeed + id.x;
    uint yIndex = floor(id.x / (numParticlesPerAxis[0]*numParticlesPerAxis[2]));
    uint zIndex = floor((id.x - (yIndex * (numParticlesPerAxis[0]*numParticlesPerAxis[2])))/numParticlesPerAxis[2]);
    uint xIndex = id.x - (yIndex * (numParticlesPerAxis[0]*numParticlesPerAxis[2])) - (zIndex * numParticlesPerAxis[2]);
    
    float3 position = float3(
        bounds[0] + particleRenderRadius + (xIndex * particleRenderRadius*2),
        bounds[1] + particleRenderRadius + (yIndex * particleRenderRadius*2),
        bounds[2] + particleRenderRadius + (zIndex * particleRenderRadius*2)
    );
    // Debug position - only use for one particle if needed
    //float3 position = origin - bounds/2.0 + float3(20.1,20.1,20.1);
    particles[id.x].position = position;
    //if (id.x < numBoids) particles[id.x].isBoid = 1;
    //else particles[id.x].isBoid = 0;
    //particles[id.x].isBoid = 0;
    //particles[id.x].touchedByBoid = 0;
    //particles[id.x].boidInfluence = float3(0,0,0);
    density[id.x] = 0;
    //pressure[id.x] = 0;
    force[id.x] = float3(0,0,0);
    velocity[id.x] = float3(0,0,0);
}

#pragma kernel GenerateGridNeighbors
[numthreads(8,8,8)]
void GenerateGridNeighbors(uint3 id : SV_DispatchThreadID) {
    if (
        id.x >= uint(numCellsPerAxis[0])
        || id.y >= uint(numCellsPerAxis[1])
        || id.z >= uint(numCellsPerAxis[2])
    ) return;
    int projectedID = GetProjectedGridIndexFromXYZ(id);
    cellLimits[projectedID].id = id;

    uint3 lower = uint3(id.x-1, id.y-1, id.z-1);
    if (lower[0] < 0) lower[0] = 0;
    if (lower[1] < 0) lower[1] = 0;
    if (lower[2] < 0) lower[2] = 0;
    cellLimits[projectedID].lowerLimits = lower;

    uint3 upper = uint3(id.x+1,id.y+1,id.z+1);
    if (upper[0] > uint(numCellsPerAxis[0]-1)) upper[0] = uint(numCellsPerAxis[0]-1);
    if (upper[1] > uint(numCellsPerAxis[1]-1)) upper[1] = uint(numCellsPerAxis[1]-1);
    if (upper[2] > uint(numCellsPerAxis[2]-1)) upper[2] = uint(numCellsPerAxis[2]-1);
    cellLimits[projectedID].upperLimits = upper;
}


#pragma kernel ClearGrid
[numthreads(_BLOCK_SIZE, 1, 1)]
// Reset the particle counts for each grid cell back to 0
void ClearGrid(uint3 id : SV_DispatchThreadID) {
    if (id.x > total_number_of_cells) return;
    grid[id.x] = 0;
}

#pragma kernel ClearForces
[numthreads(_BLOCK_SIZE, 1, 1)]
void ClearForces(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numParticles) return;
    density[id.x] = 0;
    //pressure[id.x] = 0;
    force[id.x] = float3(0,0,0);
    velocity[id.x] = float3(0,0,0);
}

#pragma kernel UpdateGridCellCounts
[numthreads(_BLOCK_SIZE,1,1)]
// Count how many particles are in each grid cell, and determine the offsets for each particle for their particular grid cell
void UpdateGridCellCounts(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numParticles) return;

    float3 p = particles[id.x].position;                                           // Get the current particle...
    int3 grid_indices = GetGridXYZIndices(p);                      // ... its XYZ grid indices ...
    int projected_index = GetProjectedGridIndexFromXYZ(grid_indices);       // ... then its 1D projected index.
    InterlockedAdd(grid[projected_index], 1, particleOffsets[id.x]);        // Add to the total count for that grid cell
    
    uint particleNeighborsStartingIndex = GetParticleNeighborStartingIndex(projected_index);  // Update `particleNeighbors`...
    if (particleOffsets[id.x] >= numParticlesPerGridCell) return;                       // ... but only if our number of particles in that cell does not exceed the limit per grid cell
    particleNeighbors[particleNeighborsStartingIndex + particleOffsets[id.x]] = id.x;    // Set the current particle within the cell as a neighbor
    //temp_buffer[id.x] = projected_index;
}

// == DENSITY CALCULATION ==
// We'll be using THIS methodology, described by https://www.cs.cornell.edu/~bindel/class/cs5220-f11/code/sph.pdf

// Helper function: calculates density for a current particle and its potential neighbor.
float CalculateDensity(uint currentIndex, uint otherIndex) {
    float3 diffPosition = particles[currentIndex].position - particles[otherIndex].position;
    float diffSquare = dot(diffPosition, diffPosition);
    if (length(diffPosition) > smoothingRadius) return 0.0;

    float z = radius2 - diffSquare;
    // float modDensity = ((4.0 * particleMass) / (pi * radius16)) * pow(z,3);
    float modDensity = ((315.0 * particleMass * pow(z,3)) / (64.0 * pi * radius9));
    //if (modDensity < 0.0001) return 0.0;
    return modDensity;
}

// The method to call by the CPU
// The general methodology is as follows:
    // 1) Initialize a list of neighbor cells to our particle's current cell
    // 2) Get those neighbor cells' projected 1D indexes, then loop through them.
        // 2a) If the projected ID is -1, then it's a bust. We break early.
        // 2b) Get thje starting index for `particleNeighbors` where that neighbor cell's particles are stored
        // 2c) Get the current number of neighbors for that cell from `grid`, using the projected ID of the neighbor cell
        // 2d) Iterate through all particles in that neighbor cell
            // i) Get the particle's ID, and check if it's the same as the current particle. Skip if so - we already handled that scenario above.
            // ii) Get the direction to the other particle from the current particle
            // iii) Get the distance between the current and other particle's centers
            // iv) Double-check that the distance between the current particle and neighbor particle is within the smoothing kernel radius. If not, continue
            // 3df) Add to density

#pragma kernel CV_ComputeDensity
[numthreads(_BLOCK_SIZE,1,1)]
void CV_ComputeDensity(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numParticles) return;

    // We get the current particle we're looking at
    float3 p = particles[id.x].position;
    int projectedID = GetProjectedGridIndexFromGivenPosition(p);
    CellLimits limits = cellLimits[projectedID];

    // We pre-emptively add the particle itself to density. This makes it easier to handle because of imprecision with float point values
    // In the original method, this step was automatically done in the loop below. however, we're just being safe here and simplifying the operation
    float _density = (315.0 * particleMass) / (64.0 * pi * radius3);
    for(uint x = limits.lowerLimits[0]; x <= limits.upperLimits[0]; x++) {
        for(uint y = limits.lowerLimits[1]; y <= limits.upperLimits[1]; y++) {
            for(uint z = limits.lowerLimits[2]; z <= limits.upperLimits[2]; z++) {
                int neighborProjectedID = GetProjectedGridIndexFromXYZ(x,y,z);
                int particleNeighborsStartingIndex = GetParticleNeighborStartingIndex(neighborProjectedID);
                int numParticlesInGridCell = grid[neighborProjectedID];
                for(uint j = particleNeighborsStartingIndex; j < particleNeighborsStartingIndex + min(numParticlesPerGridCell, numParticlesInGridCell); j++) {
                    uint otherId = particleNeighbors[j];
                    if (otherId == id.x) continue;
                    _density += CalculateDensity(id.x, otherId);
                }
            }
        }
    }
    /*
    int neighborCells[27];
    GetNeighborCellProjectedIDs(GetGridXYZIndices(p), neighborCells);
    for(int i = 0; i < 27; i++) {
        int neighborProjectedID = neighborCells[i];
        if (neighborProjectedID == -1) break;
        int particleNeighborsStartingIndex = GetParticleNeighborStartingIndex(neighborProjectedID);
        int numParticlesInGridCell = grid[neighborProjectedID];
        for(uint j = particleNeighborsStartingIndex; j < particleNeighborsStartingIndex + min(numParticlesPerGridCell, numParticlesInGridCell); j++) {
            uint otherId = particleNeighbors[j];
            if (otherId == id.x) continue;
            _density += CalculateDensity(id.x, otherId);
        }
    }
    */

    density[id.x] = _density;
}

// == PRESSURE FORCE CALCULATION ==

// Helper function: calculates pressure force between the current particle and a neighbor particle
float3 CalculatePressureForce(uint currentIndex, uint otherIndex) {
    float currentDensity = density[currentIndex];
    float neighborDensity = density[otherIndex];

    float3 diffPosition = particles[currentIndex].position - particles[otherIndex].position;
    //float diffPositionLength = sqrt(dot(diffPosition,diffPosition));
    float diffPositionLength = length(diffPosition);
    if (diffPositionLength > smoothingRadius) return float3(0,0,0);

    float c1 = particleMass * bulkModulus;
    float c2 = (currentDensity + neighborDensity - (2.0 * rest_density)) / neighborDensity;
    float c3 = -45.0 / (2 * pi * radius6);
    float3 c4 = diffPosition / diffPositionLength;
    float c5 = pow(smoothingRadius - diffPositionLength, 2);
    return c1 * c2 * c3 * c4 * c5;
}
#pragma kernel ComputePressureForce
[numthreads(_BLOCK_SIZE, 1, 1)]
// Based off of https://www.cs.cornell.edu/~bindel/class/cs5220-f11/code/sph.pdf. This calculates the interactive forces between particles
void ComputePressureForce(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numParticles) return;

    float3 p = particles[id.x].position;
    int projectedID = GetProjectedGridIndexFromGivenPosition(p);
    CellLimits limits = cellLimits[projectedID];

    float3 pressureForce = float3(0,0,0);

    for(uint x = limits.lowerLimits[0]; x <= limits.upperLimits[0]; x++) {
        for(uint y = limits.lowerLimits[1]; y <= limits.upperLimits[1]; y++) {
            for(uint z = limits.lowerLimits[2]; z <= limits.upperLimits[2]; z++) {
                int neighborProjectedID = GetProjectedGridIndexFromXYZ(x,y,z);
                int particleNeighborsStartingIndex = GetParticleNeighborStartingIndex(neighborProjectedID);
                int numParticlesInGridCell = grid[neighborProjectedID];
                for(uint j = particleNeighborsStartingIndex; j < particleNeighborsStartingIndex + min(numParticlesPerGridCell, numParticlesInGridCell); j++) {
                    uint otherId = particleNeighbors[j];
                    // Skip if we encountered each other
                    if (otherId == id.x) continue;
                    // Skip if both are boids
                    //if (particles[id.x].isBoid == 1 && particles[otherId].isBoid == 1) continue;
                    pressureForce += CalculatePressureForce(id.x, otherId);
                }
            }
        }
    }

    /*
    int neighborCells[27];
    GetNeighborCellProjectedIDs(GetGridXYZIndices(particles[id.x].position), neighborCells);
    for(int i = 0; i < 27; i++) {
        int neighborProjectedID = neighborCells[i];
        if (neighborProjectedID == -1) break;
        int particleNeighborsStartingIndex = GetParticleNeighborStartingIndex(neighborProjectedID);
        int numParticlesInGridCell = grid[neighborProjectedID];
        for(uint j = particleNeighborsStartingIndex; j < particleNeighborsStartingIndex + min(numParticlesPerGridCell, numParticlesInGridCell); j++) {
            uint otherId = particleNeighbors[j];
            // Skip if we encountered each other
            if (otherId == id.x) continue;
            // Skip if both are boids
            //if (particles[id.x].isBoid == 1 && particles[otherId].isBoid == 1) continue;
            pressureForce += CalculatePressureForce(id.x, otherId);
        }
    }
    */

    pressureForces[id.x] = pressureForce;
}

// == VISCOSITY FORCE CALCULATION ==

// Helper function: calculates viscosity force
float3 CalculateViscosityForce(uint currentIndex, uint otherIndex) {
    float neighborDensity = density[otherIndex];
    float3 diffPosition = particles[currentIndex].position - particles[otherIndex].position;
    //float diffPositionLength = sqrt(dot(diffPosition,diffPosition));
    float diffPositionLength = length(diffPosition);

    if (diffPositionLength > smoothingRadius) return float3(0,0,0);

    float3 c1 = (velocity[currentIndex] - velocity[otherIndex]) / neighborDensity;
    float c2 =  -45.0 / (pi * radius6);
    float c3 = smoothingRadius - diffPositionLength;

    return particleMass * c1 * c2 * c3;
}
#pragma kernel ComputeViscosityForce
[numthreads(_BLOCK_SIZE, 1, 1)]
// Based off of https://www.cs.cornell.edu/~bindel/class/cs5220-f11/code/sph.pdf. This calculates the interactive forces between particles
void ComputeViscosityForce(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numParticles) return;

    float3 p = particles[id.x].position;
    int projectedID = GetProjectedGridIndexFromGivenPosition(p);
    CellLimits limits = cellLimits[projectedID];

    float3 viscosityForce = float3(0,0,0);

    for(uint x = limits.lowerLimits[0]; x <= limits.upperLimits[0]; x++) {
        for(uint y = limits.lowerLimits[1]; y <= limits.upperLimits[1]; y++) {
            for(uint z = limits.lowerLimits[2]; z <= limits.upperLimits[2]; z++) {
                int neighborProjectedID = GetProjectedGridIndexFromXYZ(x,y,z);
                int particleNeighborsStartingIndex = GetParticleNeighborStartingIndex(neighborProjectedID);
                int numParticlesInGridCell = grid[neighborProjectedID];
                for(uint j = particleNeighborsStartingIndex; j < particleNeighborsStartingIndex + min(numParticlesPerGridCell, numParticlesInGridCell); j++) {
                    uint otherId = particleNeighbors[j];
                    // Skip if we encountered each other
                    if (otherId == id.x) continue;
                    // Skip if both are boids
                    //if (particles[id.x].isBoid == 1 && particles[otherId].isBoid == 1) continue;
                    viscosityForce += CalculateViscosityForce(id.x, otherId);
                }
            }
        }
    }

    /*
    int neighborCells[27];
    GetNeighborCellProjectedIDs(GetGridXYZIndices(particles[id.x].position), neighborCells);

    for(int i = 0; i < 27; i++) {
        int neighborProjectedID = neighborCells[i];
        if (neighborProjectedID == -1) break;
        int particleNeighborsStartingIndex = GetParticleNeighborStartingIndex(neighborProjectedID);
        int numParticlesInGridCell = grid[neighborProjectedID];
        for(uint j = particleNeighborsStartingIndex; j < particleNeighborsStartingIndex + min(numParticlesPerGridCell, numParticlesInGridCell); j++) {
            uint otherId = particleNeighbors[j];
            // Skip if we encountered each other
            if (otherId == id.x) continue;
            // Skip if both are boids
            //if (particles[id.x].isBoid == 1 && particles[otherId].isBoid == 1) continue;
            viscosityForce += CalculateViscosityForce(id.x, otherId);
        }
    }
    */

    viscosityForces[id.x] = viscosity_coefficient * viscosityForce;
}

// == INTERNAL FORCE CALCULATION - COMBINING PRESSURE AND VISCOSITY EQUATIONS
#pragma kernel ComputeInternalForces
[numthreads(_BLOCK_SIZE,1,1)]
void ComputeInternalForces(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numParticles) return;

    float3 pressureForce = float3(0,0,0);
    float3 viscosityForce = float3(0,0,0);

    float3 p = particles[id.x].position;
    int projectedID = GetProjectedGridIndexFromGivenPosition(p);
    CellLimits limits = cellLimits[projectedID];

    for(uint x = limits.lowerLimits[0]; x <= limits.upperLimits[0]; x++) {
        for(uint y = limits.lowerLimits[1]; y <= limits.upperLimits[1]; y++) {
            for(uint z = limits.lowerLimits[2]; z <= limits.upperLimits[2]; z++) {
                int neighborProjectedID = GetProjectedGridIndexFromXYZ(x,y,z);
                int particleNeighborsStartingIndex = GetParticleNeighborStartingIndex(neighborProjectedID);
                int numParticlesInGridCell = grid[neighborProjectedID];
                for(uint j = particleNeighborsStartingIndex; j < particleNeighborsStartingIndex + min(numParticlesPerGridCell, numParticlesInGridCell); j++) {
                    uint otherId = particleNeighbors[j];
                    // Skip if we encountered each other
                    if (otherId == id.x) continue;
                    // Skip if both are boids
                    //if (particles[id.x].isBoid == 1 && particles[otherId].isBoid == 1) continue;
                    pressureForce += CalculatePressureForce(id.x, otherId);
                    viscosityForce += CalculateViscosityForce(id.x, otherId);
                }
            }
        }
    }

    /*
    int neighborCells[27];
    GetNeighborCellProjectedIDs(GetGridXYZIndices(particles[id.x].position), neighborCells);
    
    for(int i = 0; i < 27; i++) {
        int neighborProjectedID = neighborCells[i];
        if (neighborProjectedID == -1) break;
        int particleNeighborsStartingIndex = GetParticleNeighborStartingIndex(neighborProjectedID);
        int numParticlesInGridCell = grid[neighborProjectedID];
        for(uint j = particleNeighborsStartingIndex; j < particleNeighborsStartingIndex + min(numParticlesPerGridCell, numParticlesInGridCell); j++) {
            uint otherId = particleNeighbors[j];
            // Skip if we encountered each other
            if (otherId == id.x) continue;
            // Skip if both are boids
            //if (particles[id.x].isBoid == 1 && particles[otherId].isBoid == 1) continue;
            pressureForce += CalculatePressureForce(id.x, otherId);
            viscosityForce += CalculateViscosityForce(id.x, otherId);
        }
    }
    */

    pressureForces[id.x] = pressureForce;
    viscosityForces[id.x] = viscosity_coefficient * viscosityForce;
}



// == ACCELERATION CALCULATION ==

// Helper function: calculates acceleration
float3 CalculateAcceleration(uint currentIndex, uint otherIndex) {
    float currentDensity = density[currentIndex];
    float neighborDensity = density[otherIndex];

    float3 diffPosition = particles[currentIndex].position - particles[otherIndex].position;
    float diffSquare = dot(diffPosition,diffPosition);
    if (diffSquare > radius2) return float3(0,0,0);
    float rbar = length(diffPosition);
    if (rbar == 0) return float3(0,0,0);

    
    float d = smoothingRadius - rbar;

    float c1 = (45.0 * particleMass) / (pi * radius6 * neighborDensity);
    float c3 = smoothingRadius / 2.0;
    float c4 = currentDensity + neighborDensity - (2.0 * rest_density);
    float3 c5 = diffPosition / rbar;
    float3 c6 = viscosity_coefficient * (velocity[currentIndex] - velocity[otherIndex]);

    float3 toReturn = c1 * d * ((c3 * c4 * c5 * d) + c6);


    //float q = sqrt(diffSquare) / smoothingRadius;
    //if (q == 0.0) q = 0.00001;
    //float u = 1 - q;
    
    // mu = viscosity coefficient = set from CPU
    // rest_density = set from CPU
    // k = bulk modulus = set from CPU

    
    //float wZero = (particleMass * u) / (pi * radius4 * currentDensity * neighborDensity);
    //float wP = wZero * 15.0 * bulkModulus * (currentDensity + neighborDensity - (2.0 * rest_density)) * (u/q);
    //float wV = wZero * 40.0 * viscosity_coefficient;

    //float3 toReturn = wP * diffPosition - wV * v;
    /*
    if (particles[otherIndex].isBoid > 0) {
        particles[currentIndex].touchedByBoid += 1;
        particles[currentIndex].boidInfluence += toReturn;
    }
    */

    return toReturn;
}
#pragma kernel CV_ComputeInteractAcceleration
[numthreads(_BLOCK_SIZE, 1, 1)]
// Based off of https://www.cs.cornell.edu/~bindel/class/cs5220-f11/code/sph.pdf. This calculates the interactive forces between particles
void CV_ComputeInteractAcceleration(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numParticles) return;

    //particles[id.x].boidInfluence = float3(0,0,0);
    //particles[id.x].touchedByBoid = 0;

    float3 p = particles[id.x].position;
    int projectedID = GetProjectedGridIndexFromGivenPosition(p);
    CellLimits limits = cellLimits[projectedID];

    float3 _acceleration = float3(0,0,0);

    for(uint x = limits.lowerLimits[0]; x <= limits.upperLimits[0]; x++) {
        for(uint y = limits.lowerLimits[1]; y <= limits.upperLimits[1]; y++) {
            for(uint z = limits.lowerLimits[2]; z <= limits.upperLimits[2]; z++) {
                int neighborProjectedID = GetProjectedGridIndexFromXYZ(x,y,z);
                int particleNeighborsStartingIndex = GetParticleNeighborStartingIndex(neighborProjectedID);
                int numParticlesInGridCell = grid[neighborProjectedID];
                for(uint j = particleNeighborsStartingIndex; j < particleNeighborsStartingIndex + min(numParticlesPerGridCell, numParticlesInGridCell); j++) {
                    uint otherId = particleNeighbors[j];
                    // Skip if we encountered each other
                    if (otherId == id.x) continue;
                    // Skip if both are boids
                    //if (particles[id.x].isBoid == 1 && particles[otherId].isBoid == 1) continue;
                    _acceleration += CalculateAcceleration(id.x, otherId);
                }
            }
        }
    }

    /*
    int neighborCells[27];
    GetNeighborCellProjectedIDs(GetGridXYZIndices(particles[id.x].position), neighborCells);
    for(int i = 0; i < 27; i++) {
        int neighborProjectedID = neighborCells[i];
        if (neighborProjectedID == -1) break;
        int particleNeighborsStartingIndex = GetParticleNeighborStartingIndex(neighborProjectedID);
        int numParticlesInGridCell = grid[neighborProjectedID];
        for(uint j = particleNeighborsStartingIndex; j < particleNeighborsStartingIndex + min(numParticlesPerGridCell, numParticlesInGridCell); j++) {
            uint otherId = particleNeighbors[j];
            // Skip if we encountered each other
            if (otherId == id.x) continue;
            // Skip if both are boids
            //if (particles[id.x].isBoid == 1 && particles[otherId].isBoid == 1) continue;
            _acceleration += CalculateAcceleration(id.x, otherId);
        }
    }
    */

    force[id.x] = _acceleration / particleMass;
}

#pragma kernel ComputeExternalAcceleration
[numthreads(_BLOCK_SIZE,1,1)]
// Derived from https://www.cs.cornell.edu/~bindel/class/cs5220-f11/code/sph.pdf. This computes forces on the current particle based on external forces such as gravity
void ComputeExternalAcceleration(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numParticles) return;
    float3 p = particles[id.x].position;
    float3 sumForces = float3(0,0,0);

    //float3 gravityForce = g * particleMass;
    
    // Additional forces can be applied here!
    // if (p.isBoid == 0) sumForces += gravityForce;
    //if (p.isBoid == 0) sumForces += g;
    sumForces += g;

    force[id.x] += sumForces;
}

#pragma kernel Integrate_Debug
[numthreads(_BLOCK_SIZE,1,1)]
void Integrate_Debug(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numParticles) return;

    Particle p = particles[id.x];
    float3 v = velocity[id.x];
    float3 a = ((pressureForces[id.x] + viscosityForces[id.x]) / density[id.x]) + g;
    float3 v2 =  v + (dt * a);

    force[id.x] = a;
    velocity[id.x] = v2;
}

#pragma kernel Integrate
[numthreads(_BLOCK_SIZE, 1, 1)]
void Integrate(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numParticles) return;

    Particle p = particles[id.x];
    float3 v = velocity[id.x];
    float3 a = (pressureForces[id.x] + viscosityForces[id.x] + density[id.x] * g) / density[id.x];

    //v += dt * force[id.x];
    v += dt * a;
    //if (id.x >= numBoids) p.position += dt * v;
    p.position += dt * v;

    force[id.x] = a;
    velocity[id.x] = v;
    particles[id.x] = p;
    
    //float3 bInf = dt * p.boidInfluence;
    //p.boidInfluence = bInf;
}

#pragma kernel DampenByBounds
[numthreads(_BLOCK_SIZE,1,1)]
void DampenByBounds(uint3 id : SV_DispatchThreadID) {
    // if (id.x < numBoids || id.x >= numParticles) return;\
    if (id.x >= numParticles) return;
    
    Particle p = particles[id.x];
    float3 v = velocity[id.x];
    
    // If we're just about to hit the edge, we bounce back
    // if(particles[id.x].position.x - particleRenderRadius <= origin[0] - bounds[0]/2.0 + epsilon) {
    if(particles[id.x].position[0] - particleRenderRadius <= bounds[0] + epsilon) {
        v[0] *= damping;
        // p.position.x = origin[0] - bounds[0]/2.0 + particleRenderRadius + epsilon;
        p.position[0] = bounds[0] + particleRenderRadius + epsilon;
    }
    // else if(particles[id.x].position.x + particleRenderRadius >= origin[0] + bounds[0]/2.0 - epsilon) {
    else if(particles[id.x].position[0] + particleRenderRadius >= bounds[3] - epsilon) {
        v[0] *= damping;
        // p.position.x = origin[0] + bounds[0]/2.0 - particleRenderRadius - epsilon;
        p.position[0] = bounds[3] - particleRenderRadius - epsilon;
    }

    // if(particles[id.x].position.y - particleRenderRadius <= origin[1] - bounds[1]/2.0 + epsilon) {
    if(particles[id.x].position[1] - particleRenderRadius <= bounds[1] + epsilon) {
        v[1] *= damping;
        // p.position.y = origin[1] - bounds[1]/2.0 + particleRenderRadius + epsilon;
        p.position[1] = bounds[1] + particleRenderRadius + epsilon;
    }
    // else if(particles[id.x].position.y + particleRenderRadius >= origin[1] + bounds[1]/2.0 - epsilon) {
    else if(particles[id.x].position[1] + particleRenderRadius >= bounds[4] - epsilon) {
        v[1] *= damping;
        // p.position.y = origin[1] + bounds[1]/2.0 - particleRenderRadius - epsilon;
        p.position[1] = bounds[4] - particleRenderRadius - epsilon;
    }

    // if(particles[id.x].position.z - particleRenderRadius <= origin[2] - bounds[2]/2.0 + epsilon) {
    if(particles[id.x].position[2] - particleRenderRadius <= bounds[2] + epsilon) {
        v[2] *= damping;
        // p.position.z = origin[2] - bounds[2]/2.0 + particleRenderRadius + epsilon;
        p.position[2] = bounds[2] + particleRenderRadius + epsilon;
    }
    // else if(particles[id.x].position.z + particleRenderRadius >= origin[2] + bounds[2]/2.0 - epsilon) {
    else if(particles[id.x].position[2] + particleRenderRadius >= bounds[5] - epsilon) {
        v[2] *= damping;
        p.position[2] = bounds[5] - particleRenderRadius - epsilon;
    }

    velocity[id.x] = v;
    particles[id.x] = p;
}

/*
#pragma kernel IntegrateBoidsParticles
[numthreads(_BLOCK_SIZE,1,1)]
void IntegrateBoidsParticles(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numBoids) return;
    particles[id.x].position = boids[id.x].position;
    velocity[id.x] = boidVelocities[id.x];
}
*/
