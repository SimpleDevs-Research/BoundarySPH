// ====================== //
// ===== PRIMITIVES ===== //
// ====================== //

/// Represents the STATIC properties of an obstacle. This includes the vertex, triangle, and edge indices.
struct ObstacleStatic {
    uint index;                 // Ref. index inside the obstacles arrays.
    uint2 vs;                   // [0] = starting index in the vertices arrays, [1] = the number of vertices.
    uint2 ts;                   // [0] = starting index in the triangles arrays, [1] = the number of triangles.
    uint2 es;                   // [0] = starting index in the edges arrays, [1] = the number of edges.
    float mass;                 // The mass of the obstacle. Considered a "static" variable because mass doesn't change.
    uint has_rb;
    uint has_smr;
    float3 lowerBound;
    float3 upperBound;
};

/// Represents the DYNAMIC properties of an obstacle that change during the update lop.
struct ObstacleDynamic {
    uint index;                  // Ref. index inside the obstacles arrays.
    uint isBoid;
    uint boidIndex;
    uint2 vs;                   // [0] = starting index in the vertices arrays, [1] = the number of vertices.
    uint2 ts;                   // [0] = starting index in the triangles arrays, [1] = the number of triangles.
    uint2 es;                   // [0] = starting index in the edges arrays, [1] = the number of edges.
    float3 position;            // The world-space position of the transform.
    float4 rotation;            // The world-space rotation of the transform.
    float3 scale;               // The world-space scale of the transform. Typically via `Transform.LossyScale`.
    float density;
    float3 lowerBound;          // The lower boundary position of this obstacle's bounding box.
    float3 upperBound;          // The upper boundary position of this obstacle's bounding box.
    uint isStatic;
    uint applyExternalForces;
    uint applyGravity;
    float3 centerOfMass;
    float frictionCoefficient;  // The amount of friction the object is meant to exhibit on particles.
    float restitutionCoefficient;
    uint checkObstacleBounds;
    uint checkTriangleBounds;
    uint hasChanged;             // A boolean indicator to determine if this obstacle had transformed in some way between the previous and current frame.
};

/// Represents the STATIC properties of each vertex. These values do not change at any point after the pre-processing stage.
struct VertexStatic {
    uint obstacleIndex;         // Ref. index to its parent obstacle in the obstacles arrays.
    float3 localPosition;       // The position of the vertex relative to the local space of the mesh. This will never change.
    float3 localNormal;      // The local endpoint of the 3D normal vector if starting from `localPosition`
};
/// Represents the DYNAMIC properties of each vertex. These values have to be updated if the parent obstacle has been transformed between the previous and current frames.
struct VertexDynamic {
    uint obstacleIndex;         // Ref. index to its parent obstacle in the obstacles arrays.
    float3 position;            // The current world-space position of this vertex.
    float3 normal;              // The current world-space, 3D normal vector of this vertex.
    float3 force;               // The calculated force based on the current velocity and previous velocity, which is F=m*(v/t)
};

/// Represents the STATIC properties of each triangle. These values never change after the pre-processing stage
struct TriangleStatic {
    uint obstacleIndex;     // Ref. index to its parent obstacle in the obstacles arrays.
    uint3 vertices;         // v1,v2,v3 - The indices of the three vertices of this triangle, referencing values in the vertices arrays. Organized in order of v1,v2,v3.
    float3 angles;          // v1,v2,v3 - The angles of each vertex. Used as weights in the calculation of the 3D normal vectors for each vertex. Organized in order of v1,v2,v3.
    uint3 edges;            // v1v2,v1v3,v2v3 - The indices of the three edges of this triangle, referencing values in the edges array. Organized in order of v1v2,v1v3,v2v3.
    float3 localCenter;     // The local-space centroid of the triangle.
    float3 localNormal;     // The local endpoint of the 3D normal vector if starting from `localCenter`
};
/// Represents the DYNAMIC properties of each triangle. These values are updated whenever the parent object is transformed between the previous and current frames.
struct TriangleDynamic {
    uint obstacleIndex;     // Ref. index to its parent obstacle in the obstacles arrays.
    float3 center;          // The world-space centroid of the triangle, defined by calculating the average of the world-space positions of each vertex.
    float3 normal;          // The world-space face normal vector of the triangle, calculated as the cross product of two edges v1v2 and v1v3
    float d;                // The signed distance of the plane to the origin (0,0,0). Needed to calculate the projection points onto the plane defined by this triangle.
    uint3 vertices;
    uint3 edges;
    float3 v1v2n;           // The world-space 2D normal vector of the v1v2 edge.
    float3 v1v3n;           // The world-space 2D normal vector of the v1v3 edge.
    float3 v2v3n;           // The world-space 2D normal vector of the v2v3 edge.
    float3 lowerBound;      // The lower boundary position of this triangle's bounding box.
    float3 upperBound;      // The upper boundary position of this triangle's bounding box.
};

/// Represents the STATIC properties of each edge. These values will never change after the pre-processing stage.
struct EdgeStatic {
    uint obstacleIndex;     // Ref. index to its parent obstacle in the obstacles arrays.
    uint2 vertices;         // The indices of the two vertices of this edge, referencing values in the vertices arrays. Order is typically ascending in nature.
    uint2 triangles;        // The indices of the two triangles of this edge, referencing values in the triangles arrays. Order is not important.
    float3 midpoint;        // The middle point on the edge between the two vertices.
    float3 localNormal;  // The local-space endpoint of the 3D normal vector of the edge, if starting from the local midpoint of the edge line.
};

// Represents a fluid particle in the simulation
struct Particle {
    float3 position;
    float3 force;
    int render;
};
struct Projection {
    uint triangleID;
    float3 projection;
    float3 position;
    float3 normal;
    float3 particle_force;      // The force exerted inward by the particle
    float3 external_force;      // The force exerted outward by the boundary due to velocity
    int counter;
    float frictionCoefficient;
    float restitutionCoefficient;

    float3 e1;
    float3 e2;
    float3 e1_2DN;
    float3 e2_2DN;
    float3 e1_3DN;
    float3 e2_3DN;
};
struct Boid2 {
    int obstacleID;
    float visualRange;
    float innerRange;
    float boundaryRange;
    float minSpeed;
    float maxSpeed;
    float turnSpeed;
    float cohesionFactor;
    float separationFactor;
    float alignmentFactor;

    int3 boundaryNormal;
    int boundaryTriCount;
};

// ===================== //
// ===== VARIABLES ===== //
// ===================== //

uint numGridCells;
float gridCellSize;
float gridScalingX;
float gridScalingY;
float gridScalingZ;
int3 numCellsPerAxis;
int numGridBlocks;
uint d;

uint numObstacles;
uint numVertices;
uint numTriangles;
uint numEdges;

uint numParticles;
float particleRenderRadius;

float3 g;
float dt;                       // delta time - The time difference between frames.

// ============================ //
// ===== HELPER FUNCTIONS ===== //
// ============================ //

// https://answers.unity.com/questions/372371/multiply-quaternion-by-vector3-how-is-done.html
float3 RotMultVec3(float4 quat, float3 vec){
    float num = quat[0] * 2.0;
    float num2 = quat[1] * 2.0;
    float num3 = quat[2] * 2.0;
    float num4 = quat[0] * num;
    float num5 = quat[1] * num2;
    float num6 = quat[2] * num3;
    float num7 = quat[0] * num2;
    float num8 = quat[0] * num3;
    float num9 = quat[1] * num3;
    float num10 = quat[3] * num;
    float num11 = quat[3] * num2;
    float num12 = quat[3] * num3;

    float x = (1.0 - (num5 + num6)) * vec[0] + (num7 - num12) * vec[1] + (num8 + num11) * vec[2];
    if (abs(x) < 0.000000000001) x = 0;
    float y = (num7 + num12) * vec[0] + (1.0 - (num4 + num6)) * vec[1] + (num9 - num10) * vec[2];
    if (abs(y) < 0.000000000001) y = 0;
    float z = (num8 - num11) * vec[0] + (num9 + num10) * vec[1] + (1.0 - (num4 + num5)) * vec[2];
    if (abs(z) < 0.000000000001) z = 0;
    return float3(x,y,z);
}
// https://forum.unity.com/threads/whats-the-math-behind-transform-transformpoint.107401/
float3 LocalPointToWorldPoint(float3 pos, float4 rot, float3 scale, float3 localPoint) {
    float3 s = float3(localPoint[0] * scale[0], localPoint[1] * scale[1], localPoint[2] * scale[2]);
    return RotMultVec3(rot, s) + pos;
}
int PointInsideBound(float3 position, float3 lowerBounds, float3 upperBounds) {
    if (
        lowerBounds[0] <= position[0] && position[0] <= upperBounds[0]
        && lowerBounds[1] <= position[1] && position[1] <= upperBounds[1] 
        && lowerBounds[2] <= position[2] && position[2] <= upperBounds[2]    
    ) return 1;
    return 0;
}

// Getting the XYZ grid coordinates based on position
int3 GetGridXYZIndices(float3 position) {
    return int3(
        floor((position[0] - gridScalingX)/gridCellSize),
        floor((position[1] - gridScalingY)/gridCellSize),
        floor((position[2] - gridScalingZ)/gridCellSize)
    );
}
// Getting the 1D index from a grid's XYZ coordinates
int GetProjectedGridIndexFromXYZ(int3 xyz) {
    return xyz.x + (numCellsPerAxis[0] * xyz.y) + (numCellsPerAxis[0] * numCellsPerAxis[1] * xyz.z);
}

// =================== //
// ===== BUFFERS ===== //
// =================== //

RWStructuredBuffer<int> grid;
RWStructuredBuffer<int> obstacle_offsets;
RWStructuredBuffer<int> grid_offsets;
RWStructuredBuffer<int> grid_offsets_in;
RWStructuredBuffer<int> grid_sums_buffer;
RWStructuredBuffer<int> grid_sums_buffer_in;
RWStructuredBuffer<uint> rearranged_obstacles;
RWStructuredBuffer<Boid2> boid_settings;
StructuredBuffer<float> boid_bounds;

StructuredBuffer<ObstacleStatic> obstacles_static;
RWStructuredBuffer<ObstacleDynamic> obstacles_dynamic;
StructuredBuffer<VertexStatic> vertices_static;
RWStructuredBuffer<VertexDynamic> vertices_dynamic;
StructuredBuffer<TriangleStatic> triangles_static;
RWStructuredBuffer<TriangleDynamic> triangles_dynamic;
StructuredBuffer<EdgeStatic> edges_static;
RWStructuredBuffer<float3> edges_dynamic;
RWStructuredBuffer<int3> translational_forces;
RWStructuredBuffer<int3> torque_forces;

RWStructuredBuffer<float3> obstacle_velocities;

RWStructuredBuffer<Particle> particles;
RWStructuredBuffer<Projection> projections;

StructuredBuffer<int> inputVals;
RWStructuredBuffer<int> outputVals;

#pragma kernel FindMin(uint id : SV_DispatchThreadID, )

#pragma kernel ResetVertexForces
[numthreads(64,1,1)]
void ResetVertexForces(uint id : SV_DispatchThreadID) {
    if (id >= numVertices) return;
    vertices_dynamic[id].force = float3(0,0,0);
}

#pragma kernel UpdateBounds
[numthreads(16,1,1)]
void UpdateBounds(uint id : SV_DispatchThreadID) {
    // All the mandatory checks
    if (id >= numObstacles) return;
    ObstacleDynamic o_dynamic = obstacles_dynamic[id];
    if (o_dynamic.hasChanged == 0) return;
    // Grab the local bound data
    ObstacleStatic o_static = obstacles_static[id];
    // Calculate the world positiosn of the lower and upper bounds
    o_dynamic.lowerBound = LocalPointToWorldPoint(o_dynamic.position, o_dynamic.rotation, o_dynamic.scale, o_static.lowerBound);
    o_dynamic.upperBound = LocalPointToWorldPoint(o_dynamic.position, o_dynamic.rotation, o_dynamic.scale, o_static.upperBound);
    // Because sometimes the lower and upper bounds can be flipped on one or more axes, we have to check and readjust if necessary
    float temp;
    if (o_dynamic.upperBound[0] < o_dynamic.lowerBound[0]) {
        temp = o_dynamic.lowerBound[0];
        o_dynamic.lowerBound[0] = o_dynamic.upperBound[0];
        o_dynamic.upperBound[0] = temp;
    }
    if (o_dynamic.upperBound[1] < o_dynamic.lowerBound[1]) {
        temp = o_dynamic.lowerBound[1];
        o_dynamic.lowerBound[1] = o_dynamic.upperBound[1];
        o_dynamic.upperBound[1] = temp;
    }
    if (o_dynamic.upperBound[2] < o_dynamic.lowerBound[2]) {
        temp = o_dynamic.lowerBound[2];
        o_dynamic.lowerBound[2] = o_dynamic.upperBound[2];
        o_dynamic.upperBound[2] = temp;
    }
    // Add buffers to the lower and upper bounds
    o_dynamic.lowerBound -= float3(particleRenderRadius, particleRenderRadius, particleRenderRadius);
    o_dynamic.upperBound += float3(particleRenderRadius, particleRenderRadius, particleRenderRadius);
    // Set the data
    obstacles_dynamic[id] = o_dynamic;

}

#pragma kernel UpdateVertices
[numthreads(16,1,1)]
void UpdateVertices(uint id : SV_DispatchThreadID) {
    /*
    if (id >= numVertices) return;
    // Get the necessary references
    VertexStatic v_static = vertices_static[id];
    VertexDynamic v_dynamic = vertices_dynamic[id];
    ObstacleStatic o_static = obstacles_static[v_dynamic.obstacleIndex];
    ObstacleDynamic o_dynamic = obstacles_dynamic[v_dynamic.obstacleIndex];
    // Only update if the obstacle needs to be updated
    if (o_dynamic.hasChanged == 0) return;
    
    // Get th world position and force of the vertex. If the obstacle does NOT have a skinned mesh renderer, calcualte manually. Otherwise, just get the data as-is
    float3 worldPosition;
    if (o_static.has_smr == 0) {
        // Convert to World Position of the vertex
        worldPosition = LocalPointToWorldPoint(o_dynamic.position, o_dynamic.rotation, o_dynamic.scale, v_static.localPosition);
        // Update the exertion force the vertex will push onto particles.  Calculated first before the position is updated
        v_dynamic.force = (worldPosition - v_dynamic.position)/dt;
        // Update the world position of the current vertex
        v_dynamic.position = worldPosition;
    }
    else {
        // We already have the world position and forces set if we're dealing with a skinned mesh renderer
        worldPosition = v_dynamic.position;
    }
    // Update the world normal of the current vertex
    v_dynamic.normal = normalize(RotMultVec3(o_dynamic.rotation, v_static.localNormal));
    // Upate our entry in Vertices_Dynamic
    vertices_dynamic[id] = v_dynamic;
    */

    
    if (id >= numObstacles) return;
    ObstacleDynamic o_dynamic = obstacles_dynamic[id];
    // Only update if the obstacle needs to be updated
    if (o_dynamic.hasChanged == 0) return;
    ObstacleStatic o_static = obstacles_static[id];
    VertexStatic v_static;
    VertexDynamic v_dynamic;
    float3 worldPosition;
    for(uint i = o_static.vs[0]; i < o_static.vs[0]+o_static.vs[1]; i++) {
        v_static = vertices_static[i];
        v_dynamic = vertices_dynamic[i];        
        // If the obstacle has a skinned mesh renderer, then we have already updated the world positions of the vertices
        if (o_static.has_smr == 0) {
            worldPosition = LocalPointToWorldPoint(o_dynamic.position, o_dynamic.rotation, o_dynamic.scale, v_static.localPosition);
            // Update the exertion force the vertex will push onto particles.  Calculated first before the position is updated
            v_dynamic.force = (worldPosition - v_dynamic.position)/dt;
            // Update the world position of the current vertex
            v_dynamic.position = worldPosition;
        }
        else {
            // We already have the world position and forces set
            worldPosition = v_dynamic.position;
        }
        
        // Update the world normal of the current vertex
        v_dynamic.normal = normalize(RotMultVec3(o_dynamic.rotation, v_static.localNormal));
        // Upate our entry in Vertices_Dynamic
        vertices_dynamic[i] = v_dynamic;
        // Update the bounds of our object
        o_dynamic.lowerBound[0] = min(o_dynamic.lowerBound[0], v_dynamic.position[0]-2.0*particleRenderRadius);
        o_dynamic.lowerBound[1] = min(o_dynamic.lowerBound[1], v_dynamic.position[1]-2.0*particleRenderRadius);
        o_dynamic.lowerBound[2] = min(o_dynamic.lowerBound[2], v_dynamic.position[2]-2.0*particleRenderRadius);
        o_dynamic.upperBound[0] = max(o_dynamic.upperBound[0], v_dynamic.position[0]+2.0*particleRenderRadius);
        o_dynamic.upperBound[1] = max(o_dynamic.upperBound[1], v_dynamic.position[1]+2.0*particleRenderRadius);
        o_dynamic.upperBound[2] = max(o_dynamic.upperBound[2], v_dynamic.position[2]+2.0*particleRenderRadius);
    }
    obstacles_dynamic[id] = o_dynamic;
    
    /*
    if (id >= numVertices) return;
    
    // References
    VertexStatic v_static = vertices_static[id];
    VertexDynamic v_dynamic = vertices_dynamic[id];
    ObstacleStatic o_static = obstacles_static[v_dynamic.obstacleIndex];
    ObstacleDynamic o_dynamic = obstacles_dynamic[v_dynamic.obstacleIndex];
    // Only update if the obstacle needs to be updated
    if (o_dynamic.hasChanged == 0) return;
    
    // Convert into world position
    float3 worldPosition = LocalPointToWorldPoint(o_dynamic.position, o_dynamic.rotation, o_dynamic.scale, v_static.localPosition);
    // Update the world position of the current vertex
    v_dynamic.position = worldPosition;
    // Update the world normal of the current vertex
    v_dynamic.normal = normalize(RotMultVec3(o_dynamic.rotation, v_static.localNormal));

    // Upate our entry in Vertices_Dynamic
    vertices_dynamic[id] = v_dynamic;    
    */
}

#pragma kernel UpdateEdges
[numthreads(64,1,1)]
void UpdateEdges(uint id : SV_DispatchThreadID) {
    if (id >= numEdges) return;
    
    // References
    EdgeStatic e_static         = edges_static[id];
    ObstacleDynamic o_dynamic   = obstacles_dynamic[e_static.obstacleIndex];
    
    // Update only if the current object has changed
    if (o_dynamic.hasChanged == 0) return;
    edges_dynamic[id] = normalize(RotMultVec3(o_dynamic.rotation,e_static.localNormal));
}

#pragma kernel UpdateTriangles
[numthreads(64,1,1)]
void UpdateTriangles(uint id : SV_DispatchThreadID) {
    if (id >= numTriangles) return;
        
    // References
    TriangleStatic t_static     = triangles_static[id];
    TriangleDynamic t_dynamic   = triangles_dynamic[id];
    ObstacleDynamic o_dynamic   = obstacles_dynamic[t_dynamic.obstacleIndex];
    ObstacleStatic o_static     = obstacles_static[t_dynamic.obstacleIndex];
    
    // Skip if no need to update
    if (o_dynamic.hasChanged == 0) return;
    
    // Getting updated vertex positions
    VertexDynamic v1f = vertices_dynamic[o_static.vs[0] + t_static.vertices[0]];
    VertexDynamic v2f = vertices_dynamic[o_static.vs[0] + t_static.vertices[1]];
    VertexDynamic v3f = vertices_dynamic[o_static.vs[0] + t_static.vertices[2]];
    float3 v1 = v1f.position;
    float3 v2 = v2f.position;
    float3 v3 = v3f.position;
    
    // Updating center
    //t_dynamic.center = LocalPointToWorldPoint(o_dynamic.position, o_dynamic.rotation, o_dynamic.scale, t_static.localCenter);
    t_dynamic.center = (v1 + v2 + v3)/3.0;
    // Updating normal
    //t_dynamic.normal = normalize(RotMultVec3(o_dynamic.rotation, t_static.localNormal));
    t_dynamic.normal = normalize(cross(v2-v1, v3-v1));
    // Updating d
    t_dynamic.d = dot(-1.0 * t_dynamic.center, t_dynamic.normal);
    
    // Update lowerBound and upperBound;
    t_dynamic.lowerBound = float3(
        min(min(v1[0],v2[0]),v3[0]) - (particleRenderRadius*2),
        min(min(v1[1],v2[1]),v3[1]) - (particleRenderRadius*2),
        min(min(v1[2],v2[2]),v3[2]) - (particleRenderRadius*2)
    );
    t_dynamic.upperBound = float3(
        max(max(v1[0],v2[0]),v3[0]) + (particleRenderRadius*2),
        max(max(v1[1],v2[1]),v3[1]) + (particleRenderRadius*2),
        max(max(v1[2],v2[2]),v3[2]) + (particleRenderRadius*2)
    );
    
    // updating v1v2n, v1v3n, v2v3n
    float3 v1v2 = v2 - v1;
    float3 v1c = t_dynamic.center - v1;
    float3 v2v3 = v3 - v2;
    float3 v2c = t_dynamic.center - v2;
    float3 v1v3 = v3-v1;
    t_dynamic.v1v2n = -normalize(v1c - (dot(v1c,v1v2)/dot(v1v2,v1v2))*v1v2);
    t_dynamic.v1v3n = -normalize(v1c - (dot(v1c,v1v3)/dot(v1v3,v1v3))*v1v3);
    t_dynamic.v2v3n = -normalize(v2c - (dot(v2c,v2v3)/dot(v2v3,v2v3))*v2v3);

    // Update our entry in the array
    triangles_dynamic[id] = t_dynamic;
}

#pragma kernel ResetHasChanged
[numthreads(64,1,1)]
void ResetHasChanged(uint id : SV_DispatchThreadID) {
    if (id >= numObstacles) return;
    obstacles_dynamic[id].hasChanged = 0;
}

#pragma kernel ResetTempProjections
[numthreads(64,1,1)]
void ResetTempProjections(uint id : SV_DispatchThreadID) {
    if (id >= numParticles) return;
    Projection projection = projections[id];
    projection.triangleID = numTriangles;
    projection.projection = particles[id].position;
    projection.position = particles[id].position;
    projection.normal = float3(0,0,0);
    projection.particle_force = float3(0,0,0);
    projection.external_force = float3(0,0,0);
    projection.counter = 0;
    projection.frictionCoefficient = 0;

    projection.e1 = float3(0,0,0);
    projection.e2 = float3(0,0,0);
    projection.e1_2DN = float3(0,0,0);
    projection.e2_2DN = float3(0,0,0);
    projection.e1_3DN = float3(0,0,0);
    projection.e2_3DN = float3(0,0,0);

    projections[id] = projection;

    //translational_forces[id] = int3(0,0,0);
    //torque_forces[id] = int3(0,0,0);
}

#pragma kernel ClearAppliedPressures
[numthreads(8,1,1)]
void ClearAppliedPressures(uint id : SV_DispatchThreadID) {
    if (id >= (uint)numObstacles) return;
    translational_forces[id] = int3(0,0,0);
    ObstacleDynamic o_dynamic = obstacles_dynamic[id];
    if (o_dynamic.isBoid == 1) {
        boid_settings[o_dynamic.boidIndex].boundaryNormal = int3(0,0,0);
        boid_settings[o_dynamic.boidIndex].boundaryTriCount = 0;
    }
}

#pragma kernel ClearGrid
[numthreads(64,1,1)]
void ClearGrid(uint id : SV_DispatchThreadID) {
    if (id >= numGridCells) return;
    grid[id] = 0;
}

#pragma kernel UpdateGridCellCounts
[numthreads(16,1,1)]
void UpdateGridCellCounts(uint id : SV_DispatchThreadID) {
    if (id >= numObstacles) return;
    ObstacleDynamic o_dynamic = obstacles_dynamic[id];
    int3 gridIndices = GetGridXYZIndices(o_dynamic.position);
    int projectedGridIndex = GetProjectedGridIndexFromXYZ(gridIndices);
    //b.gridIndices = gridIndices;
    //b.projectedGridIndex = projectedGridIndex;
    InterlockedAdd(grid[projectedGridIndex], 1, obstacle_offsets[id]);
    //boids[id] = b;
}

#pragma kernel PrefixSum
groupshared int temp[128];
[numthreads(64, 1, 1)]
void PrefixSum(uint projectedCellID : SV_DispatchThreadID, uint threadID : SV_GroupThreadID, uint groupID : SV_GroupID) {
    int pout = 0;
    int pin = 1;
    // Our input is `grid`
    temp[threadID] = grid_offsets_in[projectedCellID];
    GroupMemoryBarrierWithGroupSync();
    [unroll]
    for(uint offset = 1; offset < 64; offset *= 2) {
        pout = 1 - pout;
        pin = 1 - pin;
        if (threadID >= offset) {
            temp[pout * 64 + threadID] = temp[pin * 64 + threadID] + temp[pin * 64 + threadID - offset];
        } else {
            temp[pout * 64 + threadID] = temp[pin * 64 + threadID];
        }
        GroupMemoryBarrierWithGroupSync();
    }

    if (projectedCellID >= uint(numGridCells)) return;

    // We output to `grid_offsets`
    grid_offsets[projectedCellID] = temp[pout * 64 + threadID];
    if (threadID == 0) {
        // We output to `gridSumsBuffer2`
        grid_sums_buffer[groupID] = temp[pout * 64 + 64 - 1];
    }
}
#pragma kernel SumBlocks
[numthreads(64, 1, 1)]
void SumBlocks(uint id : SV_DISPATCHTHREADID) {
  if (id >= uint(numGridBlocks)) return;
  uint k = id;
  if (k < d) grid_sums_buffer[k] = grid_sums_buffer_in[k];
  else grid_sums_buffer[k] = grid_sums_buffer_in[k] + grid_sums_buffer_in[k - d];
}
#pragma kernel AddSums
[numthreads(64, 1, 1)]
void AddSums(uint projectedGridIndex : SV_DispatchThreadID, uint groupID : SV_GroupID) {
  if (groupID == 0 || projectedGridIndex > uint(numGridCells)) return;
  // Output to `grid_offsets`
  grid_offsets[projectedGridIndex] += grid_sums_buffer_in[groupID - 1];
}
#pragma kernel RearrangeObstacles
[numthreads(64, 1, 1)]
void RearrangeObstacles(uint id : SV_DispatchThreadID) {
  if (id >= uint(numObstacles)) return;
  ObstacleDynamic o_dynamic = obstacles_dynamic[id];
  int3 gridIndices = GetGridXYZIndices(o_dynamic.position);
  int projectedGridIndex = GetProjectedGridIndexFromXYZ(gridIndices);
  int index = grid_offsets[projectedGridIndex] - 1 - obstacle_offsets[id];
  rearranged_obstacles[index] = id;
}

int CheckVoroniRegions(
        float3 proj,                    // the projection of 3D point onto the 2D plane
        float3 v, float3 vN,            // the comparison vertex of the triangle + its normal
        float3 e1, float3 e2,           // The two edges connected to v1
        float3 e1_2DN, float3 e2_2DN,   // The 2D normals of the two edges
        float3 e1_3DN, float3 e2_3DN,   // The 3D normals of the two edges
        float3 tri_N,                    // The normal of the triangle itself
        float threshold,                // The threshold value for edge comparison
        out float3 closestPoint,
        out float3 closestNormal
) {
    // Determine vector from vertex to position
    float3 v_to_p = proj - v;
    
    // Now, the position is closest to the vertex if the dot(edge1 , v_to_p) <= 0 AND dot(edge2, v_to_p) <= 0
    float d1 = dot(e1, v_to_p);
    float d2 = dot(e2, v_to_p);
    if (d1 <= 0 && d2 <= 0) {
        closestPoint = v;
        closestNormal = vN;
        // We need to check if the point is actually the vertex 
        //if (d1 == 0 && d2 == 0) return 1;
        //return 0;
        return 1;
    }
    
    // At this point, we need to check if position is closer to edge1 or edge2. This is via dot product comparison
    // We introduce a "threshold" because float points are finicky and there's a margin for error w.r.t. if the projection is exactly on the line
    float d3 = dot(e1_2DN, v_to_p);
    if (d3 >= threshold) {
        closestPoint = v+ e1 * abs((d1 / dot(e1, e1)));
        closestNormal = e1_3DN;
        //if (d3 == threshold) return 1;
        //return 0;
        return 2;
    }
    float d4 = dot(e2_2DN, v_to_p);
    if (d4 >= threshold) {
        closestPoint = v + e2 * abs((d2 / dot(e2, e2)));
        closestNormal = e2_3DN;
        //if (d4 == threshold) return 1;
        //return 0;
        return 2;
    }

    // At this point, the point is inside the triangle. No need to reproject
    closestPoint = proj;
    closestNormal = tri_N;
    //return 1;
    return 3;
}
#pragma kernel CheckForProjection
[numthreads(256,1,1)]
void CheckForProjection(uint id : SV_DispatchThreadID ) {
    if (id >= numParticles) return;

    // References
    Particle particle = particles[id];
    Projection projection = projections[id];

    ObstacleStatic o_static;
    ObstacleDynamic o_dynamic;
    
    for(uint oi = 0; oi < numObstacles; oi++) {
        int meshobs_found = 0;
        float3 meshobs_closest_point = particle.position;
        float meshobs_closest_distance = 0.0;
        float3 meshobs_closest_normal = float3(0,0,0);

        o_dynamic = obstacles_dynamic[oi];
        
        // Skip if the particle isn't in the boundaries of this obstacle
        if (o_dynamic.checkObstacleBounds == 1 && PointInsideBound(particle.position, o_dynamic.lowerBound, o_dynamic.upperBound) == 0) continue;

        // grab the static obstacle
        //o_static = obstacles_static[oi];
        
        // Iterate through the vertices
        for(uint i = o_dynamic.ts[0]; i < o_dynamic.ts[0] + o_dynamic.ts[1]; i++) {
            TriangleDynamic tri_dynamic = triangles_dynamic[i];
    
            // Check if the particle is inside the triangle's boundaries
            if (o_dynamic.checkTriangleBounds == 1 && PointInsideBound(particle.position, tri_dynamic.lowerBound, tri_dynamic.upperBound) == 0) continue;
    
            // More references
            //TriangleStatic tri_static = triangles_static[i];
            //VertexDynamic v1 = vertices_dynamic[o_static.vs[0] + tri_static.vertices[0]];
            //VertexDynamic v2 = vertices_dynamic[o_static.vs[0] + tri_static.vertices[1]];
            //VertexDynamic v3 = vertices_dynamic[o_static.vs[0] + tri_static.vertices[2]];
            VertexDynamic v1 = vertices_dynamic[o_dynamic.vs[0] + tri_dynamic.vertices[0]];
            VertexDynamic v2 = vertices_dynamic[o_dynamic.vs[0] + tri_dynamic.vertices[1]];
            VertexDynamic v3 = vertices_dynamic[o_dynamic.vs[0] + tri_dynamic.vertices[2]];

            // At this point, we need to project the particle's position onto the plane defined by this triangle.
            // To calculate this projection, we grab the normal vector of the triangle and use that as our direction
            // Normally, we need to check if the vector from the particle's position to the centroid of the plane is parallal to the normal vector direction...
            //   ... however, in this case, we don't have to do that. This is because the direction we're using to project the particle position will always be orthogonal to the plane
            float3 dir = normalize(sign(dot(tri_dynamic.normal, tri_dynamic.center - particle.position)) * tri_dynamic.normal);
            // We need to project the point onto the plane formed by this triangle
            float dist_from_point_to_plane = -(dot(tri_dynamic.normal, particle.position) + tri_dynamic.d) / dot(tri_dynamic.normal, dir);
            float3 proj1 = particle.position + dist_from_point_to_plane * dir;

            float3 closestVertexPosition = v1.position;
            float3 closestVertexNormal = v1.normal;
            float3 edge1 = v2.position - v1.position;
            float3 edge2 = v3.position - v1.position;
            float3 e1_2DN = tri_dynamic.v1v2n;
            float3 e2_2DN = tri_dynamic.v1v3n;
            //float3 e1_3DN = edges_dynamic[o_static.es[0] + tri_static.edges[0]];
            //float3 e2_3DN = edges_dynamic[o_static.es[0] + tri_static.edges[1]];
            float3 e1_3DN = edges_dynamic[o_dynamic.es[0] + tri_dynamic.edges[0]];
            float3 e2_3DN = edges_dynamic[o_dynamic.es[0] + tri_dynamic.edges[1]];
            float denom, u, v, distfinal;
            float3 c, innermostPoint, v1force, v2force, v3force;
            
            if (distance(particle.position, v2.position) < distance(particle.position, closestVertexPosition)) {
                closestVertexPosition = v2.position;
                closestVertexNormal = v2.normal;
                edge1 = v1.position - v2.position;
                edge2 = v3.position - v2.position;
                e1_2DN = tri_dynamic.v1v2n;
                e2_2DN = tri_dynamic.v2v3n;
                //e1_3DN = edges_dynamic[o_static.es[0] + tri_static.edges[0]];
                //e2_3DN = edges_dynamic[o_static.es[0] + tri_static.edges[2]];
                e1_3DN = edges_dynamic[o_dynamic.es[0] + tri_dynamic.edges[0]];
                e2_3DN = edges_dynamic[o_dynamic.es[0] + tri_dynamic.edges[2]];
            }
            if (distance(particle.position, v3.position) < distance(particle.position, closestVertexPosition)) {
                closestVertexPosition = v3.position;
                closestVertexNormal = v3.normal;
                edge1 = v1.position - v3.position;
                edge2 = v2.position - v3.position;
                e1_2DN = tri_dynamic.v1v3n;
                e2_2DN = tri_dynamic.v2v3n;
                //e1_3DN = edges_dynamic[o_static.es[0] + tri_static.edges[1]];
                //e2_3DN = edges_dynamic[o_static.es[0] + tri_static.edges[2]];
                e1_3DN = edges_dynamic[o_dynamic.es[0] + tri_dynamic.edges[1]];
                e2_3DN = edges_dynamic[o_dynamic.es[0] + tri_dynamic.edges[2]];
            }

            float3 final_proj_position;
            float3 final_proj_normal;
            int isInTriangle = CheckVoroniRegions(
                proj1,                          // The projection of the particle position onto the plane
                closestVertexPosition, closestVertexNormal,   // The closest vertex position + its 3D normal
                edge1, edge2,                   // The two edges connected to the closest vertex
                normalize(e1_2DN), normalize(e2_2DN),                 // The 2D normals of the two connected edges
                normalize(e1_3DN), normalize(e2_3DN),                 // The 3D normals of the two connected edges
                normalize(tri_dynamic.normal),             // The triangle normal
                0.05,                            // The threshold for overlap
                final_proj_position,        // reference to the projection position
                final_proj_normal           // reference the projection normal
            );

            // Check if the particle is either in range of the boundary triangle or if it's underneath
            distfinal = distance(final_proj_position, particle.position);
            innermostPoint = particle.position - final_proj_normal * particleRenderRadius;

            if (projection.counter == 0 || distfinal < distance(projection.position, particle.position)) {
                projection.triangleID = i;
                projection.projection = proj1;
                projection.position = final_proj_position;
                projection.normal = final_proj_normal;

                // We have to calculate the force at this point
                denom = dot(projection.normal, projection.normal);
                c = cross(v3.position - v2.position, final_proj_position - v2.position);
                u = dot(projection.normal, c) / denom;
                c = cross(v1.position - v3.position, final_proj_position - v3.position);
                v = dot(projection.normal, c) / denom;
                if (dot(v1.force,projection.normal)<0) v1force = float3(0,0,0);
                else v1force = v1.force;
                if (dot(v2.force,projection.normal)<0) v2force = float3(0,0,0);
                else v2force = v2.force;
                if (dot(v3.force,projection.normal)<0) v3force = float3(0,0,0);
                else v3force = v3.force;
                projection.external_force = (u * v1force) + (v * v2force) + ((1.0-u-v) * v3force);
                if (dot(projection.external_force,projection.normal)<0) {
                    // We re-program the external force to be that it follows the tangential component of the external force only
                    float3 force_normal_comp = (dot(projection.external_force,-projection.normal)/dot(-projection.normal, -projection.normal)) * -projection.normal;
                    projection.external_force = projection.external_force - force_normal_comp;
                    //projection.external_force = -projection.external_force;
                }
                // We also have to calculate the amount of force exerted by the particle.
                // For now, we just calculate the orthogonal force based on the particle's current force
                // To calculate the force component along the normal vector, we:
                // 1) detect if the particle is within range or is intersecting with the triangle
                // 2) if so, perform the follwing: dot(normal,particle force) / length(normal)
                // since the normal is normalized, it'll just be 1. So we just calcualte dot(normal, particle force)
                //projection.particle_force = dot(-final_proj_normal, particle.force) * (-final_proj_normal);
                
                if (
                    distfinal <= particleRenderRadius 
                    || dot(final_proj_position - innermostPoint, final_proj_normal) >= 0.0
                ) {
                    projection.particle_force = dot(-final_proj_normal, particle.force) * (-final_proj_normal);
                    if (dot(projection.particle_force,final_proj_normal) > 0.0) projection.particle_force = float3(0,0,0);
                } else {
                    projection.particle_force = float3(0,0,0);
                }
                

                projection.counter = isInTriangle;
                projection.frictionCoefficient = o_dynamic.frictionCoefficient;
                projection.restitutionCoefficient = o_dynamic.restitutionCoefficient;

                projection.e1 = edge1;
                projection.e2 = edge2;
                projection.e1_2DN = e1_2DN;
                projection.e2_2DN = e2_2DN;
                projection.e1_3DN = e1_3DN;
                projection.e2_3DN = e2_3DN;
            }

            if (meshobs_found == 0 || distfinal < meshobs_closest_distance) {
                meshobs_found = 1;
                meshobs_closest_distance = distfinal;
                meshobs_closest_point = final_proj_position;
                meshobs_closest_normal = final_proj_normal;
            }
        }

        if (meshobs_found == 1) {
            float3 closest_to_proj = particle.position - meshobs_closest_point;
            float s = sign(dot(closest_to_proj,meshobs_closest_normal));
            if (length(closest_to_proj) <= 2.0*particleRenderRadius && s >= 0.0) {
                // At this point, we merely have to apply the pressure value of this grid cell in the direction towards the closest point
                float w = min( 1.0, max(0.0, (5.0*particleRenderRadius - length(closest_to_proj))/(5.0*particleRenderRadius) ));
                float3 pressure_vector = normalize(meshobs_closest_point - particle.position) * particles[id].force[0] * w;
                InterlockedAdd(translational_forces[oi][0], (int)(pressure_vector[0] * 1024.0));
                InterlockedAdd(translational_forces[oi][1], (int)(pressure_vector[1] * 1024.0));
                InterlockedAdd(translational_forces[oi][2], (int)(pressure_vector[2] * 1024.0));
                float3 com = o_dynamic.position;
                float3 torque = cross((meshobs_closest_point - com),pressure_vector);
                InterlockedAdd(torque_forces[oi][0], (int)(torque[0] * 1024.0));
                InterlockedAdd(torque_forces[oi][1], (int)(torque[1] * 1024.0));
                InterlockedAdd(torque_forces[oi][2], (int)(torque[2] * 1024.0));
                //InterlockedAdd(translational_forces[oi][0], 1);
                //InterlockedAdd(translational_forces[oi][1], 1);
                //InterlockedAdd(translational_forces[oi][2], 1);
            }
        }
    }
    
    /*
    for(uint i = 0; i < numTriangles; i++) {
        TriangleDynamic tri_dynamic = triangles_dynamic[i];
    
        // Check if the particle is inside the triangle's boundaries
        //if (PointInsideBound(particle.position, tri_dynamic.lowerBound, tri_dynamic.upperBound) == 0) continue;
    
        // More references
        TriangleStatic tri_static = triangles_static[i];
        ObstacleStatic o_static = obstacles_static[tri_static.obstacleIndex];
        ObstacleDynamic o_dynamic = obstacles_dynamic[tri_static.obstacleIndex];
        VertexDynamic v1 = vertices_dynamic[o_static.vs[0] + tri_static.vertices[0]];
        VertexDynamic v2 = vertices_dynamic[o_static.vs[0] + tri_static.vertices[1]];
        VertexDynamic v3 = vertices_dynamic[o_static.vs[0] + tri_static.vertices[2]];

        // At this point, we need to project the particle's position onto the plane defined by this triangle.
        // To calculate this projection, we grab the normal vector of the triangle and use that as our direction
        // Normally, we need to check if the vector from the particle's position to the centroid of the plane is parallal to the normal vector direction...
        //   ... however, in this case, we don't have to do that. This is because the direction we're using to project the particle position will always be orthogonal to the plane
        float3 dir = normalize(sign(dot(tri_dynamic.normal, tri_dynamic.center - particle.position)) * tri_dynamic.normal);    
        // We need to project the point onto the plane formed by this triangle
        float dist_from_point_to_plane = -(dot(tri_dynamic.normal, particle.position) + tri_dynamic.d) / dot(tri_dynamic.normal, dir);
        float3 proj1 = particle.position + dist_from_point_to_plane * dir;

        float3 closestVertexPosition = v1.position;
        float3 closestVertexNormal = v1.normal;
        float3 edge1 = v2.position - v1.position;
        float3 edge2 = v3.position - v1.position;
        float3 e1_2DN = tri_dynamic.v1v2n;
        float3 e2_2DN = tri_dynamic.v1v3n;
        float3 e1_3DN = edges_dynamic[o_static.es[0] + tri_static.edges[0]];
        float3 e2_3DN = edges_dynamic[o_static.es[0] + tri_static.edges[1]];
        if (distance(particle.position, v2.position) < distance(particle.position, closestVertexPosition)) {
            closestVertexPosition = v2.position;
            closestVertexNormal = v2.normal;
            edge1 = v1.position - v2.position;
            edge2 = v3.position - v2.position;
            e1_2DN = tri_dynamic.v1v2n;
            e2_2DN = tri_dynamic.v2v3n;
            e1_3DN = edges_dynamic[o_static.es[0] + tri_static.edges[0]];
            e2_3DN = edges_dynamic[o_static.es[0] + tri_static.edges[2]];
        }
        if (distance(particle.position, v3.position) < distance(particle.position, closestVertexPosition)) {
            closestVertexPosition = v3.position;
            closestVertexNormal = v3.normal;
            edge1 = v1.position - v3.position;
            edge2 = v2.position - v3.position;
            e1_2DN = tri_dynamic.v1v3n;
            e2_2DN = tri_dynamic.v2v3n;
            e1_3DN = edges_dynamic[o_static.es[0] + tri_static.edges[1]];
            e2_3DN = edges_dynamic[o_static.es[0] + tri_static.edges[2]];
        }

        float3 final_proj_position, final_proj_normal;
        int isInTriangle = CheckVoroniRegions(
            proj1,                          // The projection of the particle position onto the plane
            closestVertexPosition, closestVertexNormal,   // The closest vertex position + its 3D normal
            edge1, edge2,                   // The two edges connected to the closest vertex
            normalize(e1_2DN), normalize(e2_2DN),                 // The 2D normals of the two connected edges
            normalize(e1_3DN), normalize(e2_3DN),                 // The 3D normals of the two connected edges
            normalize(tri_dynamic.normal),             // The triangle normal
            0.05,                            // The threshold for overlap
            final_proj_position,        // reference to the projection position
            final_proj_normal           // reference the projection normal
        );

        if (projection.counter == 0 || distance(final_proj_position,particle.position) < distance(projection.position, particle.position)) {
            projection.triangleID = i;
            projection.projection = proj1;
            projection.position = final_proj_position;
            projection.normal = final_proj_normal;
            projection.counter = isInTriangle;
            projection.frictionCoefficient = o_dynamic.frictionCoefficient;

            projection.e1 = edge1;
            projection.e2 = edge2;
            projection.e1_2DN = e1_2DN;
            projection.e2_2DN = e2_2DN;
            projection.e1_3DN = e1_3DN;
            projection.e2_3DN = e2_3DN;
        }
    }
    */

    projections[id] = projection;
}


#pragma kernel CheckForObstaclesForBoids
[numthreads(8,64,1)]
void CheckForObstaclesForBoids(uint3 id : SV_DispatchThreadID ) {
    // As opposed to `CheckForProjection`, this `CheckForObstaclesForBoids` iterates across all triangles in the dispatch thread ID
    // This allows for iteration across two axes.
    // In fact, we will iterate across all obstacles, across all triangles.
    // Therefore, `x` = the obstacle ID (regardless of if the obstacle is a boid or not), and `y` = the triangle ID
    if (id.x >= numObstacles || id.y >= numTriangles) return;

    // First thing to check is if the obstacle is actually a boid or not. Skip if not.
    ObstacleDynamic o_dynamic = obstacles_dynamic[id.x];
    if (o_dynamic.isBoid == 0) return;

    // Second is to grab the triangle from id.y, We also need to check if the obstacle associated with this triangle is a boid or not. Return if it is
    TriangleDynamic tri_dynamic = triangles_dynamic[id.y];
    ObstacleDynamic other_dynamic = obstacles_dynamic[tri_dynamic.obstacleIndex];
    if (other_dynamic.isBoid == 1) return;

    //In `CheckForProjection`, we check if the particle is close enough to the obstacle and/or triangle.
    // However, here the visual range is very much different because the visual range of the boid is what's important.
    // Therefore, we skip the checks for bounds and instead first check the closest point projection onto the mesh
    VertexDynamic v1 = vertices_dynamic[other_dynamic.vs[0] + tri_dynamic.vertices[0]];
    VertexDynamic v2 = vertices_dynamic[other_dynamic.vs[0] + tri_dynamic.vertices[1]];
    VertexDynamic v3 = vertices_dynamic[other_dynamic.vs[0] + tri_dynamic.vertices[2]];

    // At this point, we need to project the boid's position onto the plane defined by this triangle.
    // To calculate this projection, we grab the normal vector of the triangle and use that as our direction
    // Normally, we need to check if the vector from the particle's position to the centroid of the plane is parallal to the normal vector direction...
    //   ... however, in this case, we don't have to do that. This is because the direction we're using to project the particle position will always be orthogonal to the plane
    float3 dir = normalize(sign(dot(tri_dynamic.normal, tri_dynamic.center - o_dynamic.position)) * tri_dynamic.normal);    
    // We need to project the point onto the plane formed by this triangle
    float dist_from_point_to_plane = -(dot(tri_dynamic.normal, o_dynamic.position) + tri_dynamic.d) / dot(tri_dynamic.normal, dir);
    float3 proj = o_dynamic.position + dist_from_point_to_plane * dir;

    // We now determine qualities such as closest vertex and edges
    float3 closestVertexPosition = v1.position;
    float3 closestVertexNormal = v1.normal;
    float3 edge1 = v2.position - v1.position;
    float3 edge2 = v3.position - v1.position;
    float3 e1_2DN = tri_dynamic.v1v2n;
    float3 e2_2DN = tri_dynamic.v1v3n;
    float3 e1_3DN = edges_dynamic[other_dynamic.es[0] + tri_dynamic.edges[0]];
    float3 e2_3DN = edges_dynamic[other_dynamic.es[0] + tri_dynamic.edges[1]];
            
    if (distance(o_dynamic.position, v2.position) < distance(o_dynamic.position, closestVertexPosition)) {
        closestVertexPosition = v2.position;
        closestVertexNormal = v2.normal;
        edge1 = v1.position - v2.position;
        edge2 = v3.position - v2.position;
        e1_2DN = tri_dynamic.v1v2n;
        e2_2DN = tri_dynamic.v2v3n;
        e1_3DN = edges_dynamic[other_dynamic.es[0] + tri_dynamic.edges[0]];
        e2_3DN = edges_dynamic[other_dynamic.es[0] + tri_dynamic.edges[2]];
    }
    if (distance(o_dynamic.position, v3.position) < distance(o_dynamic.position, closestVertexPosition)) {
        closestVertexPosition = v3.position;
        closestVertexNormal = v3.normal;
        edge1 = v1.position - v3.position;
        edge2 = v2.position - v3.position;
        e1_2DN = tri_dynamic.v1v3n;
        e2_2DN = tri_dynamic.v2v3n;
        e1_3DN = edges_dynamic[other_dynamic.es[0] + tri_dynamic.edges[1]];
        e2_3DN = edges_dynamic[other_dynamic.es[0] + tri_dynamic.edges[2]];
    }

    // We can now get the projection data
    float3 closest_position, closest_normal;
    int isInTriangle = CheckVoroniRegions(
        proj,                          // The projection of the particle position onto the plane
        closestVertexPosition, closestVertexNormal,   // The closest vertex position + its 3D normal
        edge1, edge2,                   // The two edges connected to the closest vertex
        normalize(e1_2DN), normalize(e2_2DN),                 // The 2D normals of the two connected edges
        normalize(e1_3DN), normalize(e2_3DN),                 // The 3D normals of the two connected edges
        normalize(tri_dynamic.normal),             // The triangle normal
        0.05,                            // The threshold for overlap
        closest_position,        // reference to the closest position
        closest_normal           // reference the normal at the closest position
    );

    // At this point, we need to check if the closest point is within the visual range of the boid. Return if not.
    float boundaryDistance = length(closest_position - o_dynamic.position);
    if (boundaryDistance > boid_settings[o_dynamic.boidIndex].boundaryRange) return;

    // At this point, we're only interested in the normal vector. This is because this normal tells the boid where to go
    // Therefore, we simply add the normal vector to a total counter in `boid_settings`
    // Where it gets complicated is the level of influence the boundary normal has on the boid re-direction
    // In concept, distances beween the boid and the closest point that are smallest should have the biggest influence
    // And those whose distances are big should be the smallest.
    // We'll use the boundaryRange as our cap, and determine the level of influence based on boundaryRange - distance
    float boundaryInfluence = boid_settings[o_dynamic.boidIndex].boundaryRange -boundaryDistance;
    float3 influencedNormal = closest_normal * boundaryInfluence;
    InterlockedAdd(boid_settings[o_dynamic.boidIndex].boundaryNormal[0], int(influencedNormal[0]*1024.0));
    InterlockedAdd(boid_settings[o_dynamic.boidIndex].boundaryNormal[1], int(influencedNormal[1]*1024.0));
    InterlockedAdd(boid_settings[o_dynamic.boidIndex].boundaryNormal[2], int(influencedNormal[2]*1024.0));
    InterlockedAdd(boid_settings[o_dynamic.boidIndex].boundaryTriCount, 1);

    /*
    Particle particle = particles[id.x];
    Projection projection = projections[id.x];

    TriangleDynamic tri_dynamic = triangles_dynamic[id.y];
    ObstacleDynamic o_dynamic = obstacles_dynamic[tri_dynamic.obstacleIndex];

    // Skip if the particle isn't in the boundaries of this obstacle
    if (o_dynamic.checkObstacleBounds == 1 && PointInsideBound(particle.position, o_dynamic.lowerBound, o_dynamic.upperBound) == 0) return;
    
    // Check if the particle is inside the triangle's boundaries
    if (o_dynamic.checkTriangleBounds == 1 && PointInsideBound(particle.position, tri_dynamic.lowerBound, tri_dynamic.upperBound) == 0) return;

    ObstacleStatic o_static = obstacles_static[tri_dynamic.obstacleIndex];
    //TriangleStatic tri_static = triangles_static[id.y];
    VertexDynamic v1 = vertices_dynamic[o_static.vs[0] + tri_dynamic.vertices[0]];
    VertexDynamic v2 = vertices_dynamic[o_static.vs[0] + tri_dynamic.vertices[1]];
    VertexDynamic v3 = vertices_dynamic[o_static.vs[0] + tri_dynamic.vertices[2]];

     // At this point, we need to project the particle's position onto the plane defined by this triangle.
    // To calculate this projection, we grab the normal vector of the triangle and use that as our direction
    // Normally, we need to check if the vector from the particle's position to the centroid of the plane is parallal to the normal vector direction...
    //   ... however, in this case, we don't have to do that. This is because the direction we're using to project the particle position will always be orthogonal to the plane
    float3 dir = normalize(sign(dot(tri_dynamic.normal, tri_dynamic.center - particle.position)) * tri_dynamic.normal);    
    // We need to project the point onto the plane formed by this triangle
    float dist_from_point_to_plane = -(dot(tri_dynamic.normal, particle.position) + tri_dynamic.d) / dot(tri_dynamic.normal, dir);
    float3 proj1 = particle.position + dist_from_point_to_plane * dir;

    float3 closestVertexPosition = v1.position;
    float3 closestVertexNormal = v1.normal;
    float3 edge1 = v2.position - v1.position;
    float3 edge2 = v3.position - v1.position;
    float3 e1_2DN = tri_dynamic.v1v2n;
    float3 e2_2DN = tri_dynamic.v1v3n;
    float3 e1_3DN = edges_dynamic[o_static.es[0] + tri_dynamic.edges[0]];
    float3 e2_3DN = edges_dynamic[o_static.es[0] + tri_dynamic.edges[1]];
            
    if (distance(particle.position, v2.position) < distance(particle.position, closestVertexPosition)) {
        closestVertexPosition = v2.position;
        closestVertexNormal = v2.normal;
        edge1 = v1.position - v2.position;
        edge2 = v3.position - v2.position;
        e1_2DN = tri_dynamic.v1v2n;
        e2_2DN = tri_dynamic.v2v3n;
        e1_3DN = edges_dynamic[o_static.es[0] + tri_dynamic.edges[0]];
        e2_3DN = edges_dynamic[o_static.es[0] + tri_dynamic.edges[2]];
    }
    if (distance(particle.position, v3.position) < distance(particle.position, closestVertexPosition)) {
        closestVertexPosition = v3.position;
        closestVertexNormal = v3.normal;
        edge1 = v1.position - v3.position;
        edge2 = v2.position - v3.position;
        e1_2DN = tri_dynamic.v1v3n;
        e2_2DN = tri_dynamic.v2v3n;
        e1_3DN = edges_dynamic[o_static.es[0] + tri_dynamic.edges[1]];
        e2_3DN = edges_dynamic[o_static.es[0] + tri_dynamic.edges[2]];
    }

    float3 final_proj_position, final_proj_normal;
    int isInTriangle = CheckVoroniRegions(
        proj1,                          // The projection of the particle position onto the plane
        closestVertexPosition, closestVertexNormal,   // The closest vertex position + its 3D normal
        edge1, edge2,                   // The two edges connected to the closest vertex
        normalize(e1_2DN), normalize(e2_2DN),                 // The 2D normals of the two connected edges
        normalize(e1_3DN), normalize(e2_3DN),                 // The 3D normals of the two connected edges
        normalize(tri_dynamic.normal),             // The triangle normal
        0.05,                            // The threshold for overlap
        final_proj_position,        // reference to the projection position
        final_proj_normal           // reference the projection normal
    );
    
    float3 projN = tri_dynamic.normal 
        * (max(0.0,dot(tri_dynamic.normal,normalize(particle.position - proj1)))) 
        * (max(0.0,min(1.0,2.0*particleRenderRadius - distance(particle.position,proj1)/particleRenderRadius)));

    float distfinal = distance(final_proj_position, particle.position);
    float3 innermostPoint = particle.position - final_proj_normal * particleRenderRadius;

    if (
        isInTriangle == 1 
        //&& length(projN) > 0.0 
        && (
            distfinal <= particleRenderRadius 
            || dot(final_proj_position - innermostPoint, final_proj_normal) >= 0.0
        )
    ) {
        // We have to calculate the force at this point
        float denom = dot(final_proj_normal, final_proj_normal);
        float3 c = cross(v3.position - v2.position, final_proj_position - v2.position);
        float u = dot(final_proj_normal, c) / denom;
        c = cross(v1.position - v3.position, final_proj_position - v3.position);
        float v = dot(final_proj_normal, c) / denom;
        float3 v1Force = v1.force;
        if (dot(v1.force,final_proj_normal) < 0.0) v1Force = float3(0,0,0);
        float3 v2Force = v2.force;
        if (dot(v2.force,final_proj_normal) < 0.0) v2Force = float3(0,0,0);
        float3 v3Force = v3.force;
        if (dot(v3.force,final_proj_normal) < 0.0) v3Force = float3(0,0,0);
        float3 external_force = (u * v1Force) + (v * v2Force) + ((1-u-v) * v3Force);

        // We also calculate the force imparted onto the obstacle by the particle
        float3 particle_force = dot(-final_proj_normal, particle.force) * (-final_proj_normal);
        if (dot(particle_force,final_proj_normal) > 0.0) particle_force = float3(0,0,0);

        // Finally, we add our calculated values
        InterlockedAdd(projections[id.x].counter, 1);
        InterlockedAdd(projections[id.x].normal[0], int(projN[0] * 1024.0));
        InterlockedAdd(projections[id.x].normal[1], int(projN[1] * 1024.0));
        InterlockedAdd(projections[id.x].normal[2], int(projN[2] * 1024.0));
        InterlockedAdd(projections[id.x].external_force[0], int(external_force[0] * 1024.0));
        InterlockedAdd(projections[id.x].external_force[1], int(external_force[1] * 1024.0));
        InterlockedAdd(projections[id.x].external_force[2], int(external_force[2] * 1024.0));
        InterlockedAdd(projections[id.x].frictionCoefficient, int(o_dynamic.frictionCoefficient * 1024.0));
        if (o_static.has_rb == 1) {
            InterlockedAdd(translational_forces[tri_dynamic.obstacleIndex][0], int(particle_force[0] * 1024));
            InterlockedAdd(translational_forces[tri_dynamic.obstacleIndex][1], int(particle_force[1] * 1024));
            InterlockedAdd(translational_forces[tri_dynamic.obstacleIndex][2], int(particle_force[2] * 1024));
        }
    }
    */
    
                                    /*

                                    if (projection.counter == 0 || distance(final_proj_position,particle.position) < distance(projection.position, particle.position)) {
                                    projection.triangleID = i;
                                    projection.projection = proj1;
                                    projection.position = final_proj_position;
                                    projection.normal = final_proj_normal;

                                                
                                        // We have to calculate the force at this point
                                                denom = dot(projection.normal, projection.normal);
                                                c = cross(v3.position - v2.position, final_proj_position - v2.position);
                                                u = dot(projection.normal, c) / denom;
                                                c = cross(v1.position - v3.position, final_proj_position - v3.position);
                                                v = dot(projection.normal, c) / denom;
                                                projection.external_force = (u * v1.force) + (v * v2.force) + ((1-u-v) * v3.force);
                                                // We also have to calculate the amount of force exerted by the particle.
                                                // For now, we just calculate the orthogonal force based on the particle's current force
                                                // To calculate the force component along the normal vector, we:
                                                // 1) detect if the particle is within range or is intersecting with the triangle
                                                // 2) if so, perform the follwing: dot(normal,particle force) / length(normal)
                                                // since the normal is normalized, it'll just be 1. So we just calcualte dot(normal, particle force)
                                                distfinal = distance(final_proj_position, particle.position);
                                                innermostPoint = particle.position - final_proj_normal * particleRenderRadius;
                                                //projection.particle_force = dot(-final_proj_normal, particle.force) * (-final_proj_normal);
                                                
                                                if (
                                                    distfinal <= particleRenderRadius 
                                                    || dot(final_proj_position - innermostPoint, final_proj_normal) >= 0.0
                                                ) {
                                                    projection.particle_force = dot(-final_proj_normal, particle.force) * (-final_proj_normal);
                                                    if (dot(projection.particle_force,final_proj_normal) > 0.0) projection.particle_force = float3(0,0,0);
                                                } else {
                                                    projection.particle_force = float3(0,0,0);
                                                }
                                                

                                                projection.counter = isInTriangle;
                                                projection.frictionCoefficient = o_dynamic.frictionCoefficient;

                                                projection.e1 = edge1;
                                                projection.e2 = edge2;
                                                projection.e1_2DN = e1_2DN;
                                                projection.e2_2DN = e2_2DN;
                                                projection.e1_3DN = e1_3DN;
                                                projection.e2_3DN = e2_3DN;
                                            }

                                    for(uint oi = 0; oi < numObstacles; oi++) {
                                        o_dynamic = obstacles_dynamic[oi];
                                        
                                        // Skip if the particle isn't in the boundaries of this obstacle
                                        if (o_dynamic.checkObstacleBounds == 1 && PointInsideBound(particle.position, o_dynamic.lowerBound, o_dynamic.upperBound) == 0) continue;

                                        // grab the static obstacle
                                        o_static = obstacles_static[oi];
                                        
                                        // Iterate through the vertices
                                        for(uint i = o_static.ts[0]; i < o_static.ts[0] + o_static.ts[1]; i++) {
                                            TriangleDynamic tri_dynamic = triangles_dynamic[i];
                                    
                                            // Check if the particle is inside the triangle's boundaries
                                            if (o_dynamic.checkTriangleBounds == 1 && PointInsideBound(particle.position, tri_dynamic.lowerBound, tri_dynamic.upperBound) == 0) continue;
                                    
                                            // More references
                                            TriangleStatic tri_static = triangles_static[i];
                                            VertexDynamic v1 = vertices_dynamic[o_static.vs[0] + tri_static.vertices[0]];
                                            VertexDynamic v2 = vertices_dynamic[o_static.vs[0] + tri_static.vertices[1]];
                                            VertexDynamic v3 = vertices_dynamic[o_static.vs[0] + tri_static.vertices[2]];

                                            // At this point, we need to project the particle's position onto the plane defined by this triangle.
                                            // To calculate this projection, we grab the normal vector of the triangle and use that as our direction
                                            // Normally, we need to check if the vector from the particle's position to the centroid of the plane is parallal to the normal vector direction...
                                            //   ... however, in this case, we don't have to do that. This is because the direction we're using to project the particle position will always be orthogonal to the plane
                                            float3 dir = normalize(sign(dot(tri_dynamic.normal, tri_dynamic.center - particle.position)) * tri_dynamic.normal);    
                                            // We need to project the point onto the plane formed by this triangle
                                            float dist_from_point_to_plane = -(dot(tri_dynamic.normal, particle.position) + tri_dynamic.d) / dot(tri_dynamic.normal, dir);
                                            float3 proj1 = particle.position + dist_from_point_to_plane * dir;

                                            float3 closestVertexPosition = v1.position;
                                            float3 closestVertexNormal = v1.normal;
                                            float3 edge1 = v2.position - v1.position;
                                            float3 edge2 = v3.position - v1.position;
                                            float3 e1_2DN = tri_dynamic.v1v2n;
                                            float3 e2_2DN = tri_dynamic.v1v3n;
                                            float3 e1_3DN = edges_dynamic[o_static.es[0] + tri_static.edges[0]];
                                            float3 e2_3DN = edges_dynamic[o_static.es[0] + tri_static.edges[1]];
                                            float denom, u, v, distfinal;
                                            float3 c, innermostPoint;
                                            
                                            if (distance(particle.position, v2.position) < distance(particle.position, closestVertexPosition)) {
                                                closestVertexPosition = v2.position;
                                                closestVertexNormal = v2.normal;
                                                edge1 = v1.position - v2.position;
                                                edge2 = v3.position - v2.position;
                                                e1_2DN = tri_dynamic.v1v2n;
                                                e2_2DN = tri_dynamic.v2v3n;
                                                e1_3DN = edges_dynamic[o_static.es[0] + tri_static.edges[0]];
                                                e2_3DN = edges_dynamic[o_static.es[0] + tri_static.edges[2]];
                                            }
                                            if (distance(particle.position, v3.position) < distance(particle.position, closestVertexPosition)) {
                                                closestVertexPosition = v3.position;
                                                closestVertexNormal = v3.normal;
                                                edge1 = v1.position - v3.position;
                                                edge2 = v2.position - v3.position;
                                                e1_2DN = tri_dynamic.v1v3n;
                                                e2_2DN = tri_dynamic.v2v3n;
                                                e1_3DN = edges_dynamic[o_static.es[0] + tri_static.edges[1]];
                                                e2_3DN = edges_dynamic[o_static.es[0] + tri_static.edges[2]];
                                            }

                                            float3 final_proj_position, final_proj_normal;
                                            int isInTriangle = CheckVoroniRegions(
                                                proj1,                          // The projection of the particle position onto the plane
                                                closestVertexPosition, closestVertexNormal,   // The closest vertex position + its 3D normal
                                                edge1, edge2,                   // The two edges connected to the closest vertex
                                                normalize(e1_2DN), normalize(e2_2DN),                 // The 2D normals of the two connected edges
                                                normalize(e1_3DN), normalize(e2_3DN),                 // The 3D normals of the two connected edges
                                                normalize(tri_dynamic.normal),             // The triangle normal
                                                0.05,                            // The threshold for overlap
                                                final_proj_position,        // reference to the projection position
                                                final_proj_normal           // reference the projection normal
                                            );

                                            if (projection.counter == 0 || distance(final_proj_position,particle.position) < distance(projection.position, particle.position)) {
                                                projection.triangleID = i;
                                                projection.projection = proj1;
                                                projection.position = final_proj_position;
                                                projection.normal = final_proj_normal;

                                                // We have to calculate the force at this point
                                                denom = dot(projection.normal, projection.normal);
                                                c = cross(v3.position - v2.position, final_proj_position - v2.position);
                                                u = dot(projection.normal, c) / denom;
                                                c = cross(v1.position - v3.position, final_proj_position - v3.position);
                                                v = dot(projection.normal, c) / denom;
                                                projection.external_force = (u * v1.force) + (v * v2.force) + ((1-u-v) * v3.force);
                                                // We also have to calculate the amount of force exerted by the particle.
                                                // For now, we just calculate the orthogonal force based on the particle's current force
                                                // To calculate the force component along the normal vector, we:
                                                // 1) detect if the particle is within range or is intersecting with the triangle
                                                // 2) if so, perform the follwing: dot(normal,particle force) / length(normal)
                                                // since the normal is normalized, it'll just be 1. So we just calcualte dot(normal, particle force)
                                                distfinal = distance(final_proj_position, particle.position);
                                                innermostPoint = particle.position - final_proj_normal * particleRenderRadius;
                                                //projection.particle_force = dot(-final_proj_normal, particle.force) * (-final_proj_normal);
                                                
                                                if (
                                                    distfinal <= particleRenderRadius 
                                                    || dot(final_proj_position - innermostPoint, final_proj_normal) >= 0.0
                                                ) {
                                                    projection.particle_force = dot(-final_proj_normal, particle.force) * (-final_proj_normal);
                                                    if (dot(projection.particle_force,final_proj_normal) > 0.0) projection.particle_force = float3(0,0,0);
                                                } else {
                                                    projection.particle_force = float3(0,0,0);
                                                }
                                                

                                                projection.counter = isInTriangle;
                                                projection.frictionCoefficient = o_dynamic.frictionCoefficient;

                                                projection.e1 = edge1;
                                                projection.e2 = edge2;
                                                projection.e1_2DN = e1_2DN;
                                                projection.e2_2DN = e2_2DN;
                                                projection.e1_3DN = e1_3DN;
                                                projection.e2_3DN = e2_3DN;
                                            }
                                        }
                                    }

                                    
                                    /*
                                    for(uint i = 0; i < numTriangles; i++) {
                                        TriangleDynamic tri_dynamic = triangles_dynamic[i];
                                    
                                        // Check if the particle is inside the triangle's boundaries
                                        //if (PointInsideBound(particle.position, tri_dynamic.lowerBound, tri_dynamic.upperBound) == 0) continue;
                                    
                                        // More references
                                        TriangleStatic tri_static = triangles_static[i];
                                        ObstacleStatic o_static = obstacles_static[tri_static.obstacleIndex];
                                        ObstacleDynamic o_dynamic = obstacles_dynamic[tri_static.obstacleIndex];
                                        VertexDynamic v1 = vertices_dynamic[o_static.vs[0] + tri_static.vertices[0]];
                                        VertexDynamic v2 = vertices_dynamic[o_static.vs[0] + tri_static.vertices[1]];
                                        VertexDynamic v3 = vertices_dynamic[o_static.vs[0] + tri_static.vertices[2]];

                                        // At this point, we need to project the particle's position onto the plane defined by this triangle.
                                        // To calculate this projection, we grab the normal vector of the triangle and use that as our direction
                                        // Normally, we need to check if the vector from the particle's position to the centroid of the plane is parallal to the normal vector direction...
                                        //   ... however, in this case, we don't have to do that. This is because the direction we're using to project the particle position will always be orthogonal to the plane
                                        float3 dir = normalize(sign(dot(tri_dynamic.normal, tri_dynamic.center - particle.position)) * tri_dynamic.normal);    
                                        // We need to project the point onto the plane formed by this triangle
                                        float dist_from_point_to_plane = -(dot(tri_dynamic.normal, particle.position) + tri_dynamic.d) / dot(tri_dynamic.normal, dir);
                                        float3 proj1 = particle.position + dist_from_point_to_plane * dir;

                                        float3 closestVertexPosition = v1.position;
                                        float3 closestVertexNormal = v1.normal;
                                        float3 edge1 = v2.position - v1.position;
                                        float3 edge2 = v3.position - v1.position;
                                        float3 e1_2DN = tri_dynamic.v1v2n;
                                        float3 e2_2DN = tri_dynamic.v1v3n;
                                        float3 e1_3DN = edges_dynamic[o_static.es[0] + tri_static.edges[0]];
                                        float3 e2_3DN = edges_dynamic[o_static.es[0] + tri_static.edges[1]];
                                        if (distance(particle.position, v2.position) < distance(particle.position, closestVertexPosition)) {
                                            closestVertexPosition = v2.position;
                                            closestVertexNormal = v2.normal;
                                            edge1 = v1.position - v2.position;
                                            edge2 = v3.position - v2.position;
                                            e1_2DN = tri_dynamic.v1v2n;
                                            e2_2DN = tri_dynamic.v2v3n;
                                            e1_3DN = edges_dynamic[o_static.es[0] + tri_static.edges[0]];
                                            e2_3DN = edges_dynamic[o_static.es[0] + tri_static.edges[2]];
                                        }
                                        if (distance(particle.position, v3.position) < distance(particle.position, closestVertexPosition)) {
                                            closestVertexPosition = v3.position;
                                            closestVertexNormal = v3.normal;
                                            edge1 = v1.position - v3.position;
                                            edge2 = v2.position - v3.position;
                                            e1_2DN = tri_dynamic.v1v3n;
                                            e2_2DN = tri_dynamic.v2v3n;
                                            e1_3DN = edges_dynamic[o_static.es[0] + tri_static.edges[1]];
                                            e2_3DN = edges_dynamic[o_static.es[0] + tri_static.edges[2]];
                                        }

                                        float3 final_proj_position, final_proj_normal;
                                        int isInTriangle = CheckVoroniRegions(
                                            proj1,                          // The projection of the particle position onto the plane
                                            closestVertexPosition, closestVertexNormal,   // The closest vertex position + its 3D normal
                                            edge1, edge2,                   // The two edges connected to the closest vertex
                                            normalize(e1_2DN), normalize(e2_2DN),                 // The 2D normals of the two connected edges
                                            normalize(e1_3DN), normalize(e2_3DN),                 // The 3D normals of the two connected edges
                                            normalize(tri_dynamic.normal),             // The triangle normal
                                            0.05,                            // The threshold for overlap
                                            final_proj_position,        // reference to the projection position
                                            final_proj_normal           // reference the projection normal
                                        );

                                        if (projection.counter == 0 || distance(final_proj_position,particle.position) < distance(projection.position, particle.position)) {
                                            projection.triangleID = i;
                                            projection.projection = proj1;
                                            projection.position = final_proj_position;
                                            projection.normal = final_proj_normal;
                                            projection.counter = isInTriangle;
                                            projection.frictionCoefficient = o_dynamic.frictionCoefficient;

                                            projection.e1 = edge1;
                                            projection.e2 = edge2;
                                            projection.e1_2DN = e1_2DN;
                                            projection.e2_2DN = e2_2DN;
                                            projection.e1_3DN = e1_3DN;
                                            projection.e2_3DN = e2_3DN;
                                        }
                                    }
                                    */

    //projections[id] = projection;
}

void CalculateBoidDirection(inout ObstacleDynamic o, inout float3 velocity, uint id) {
    float3 center = 0;
    float3 close = 0;
    float3 avgVel = 0;
    int neighbors = 0;

    // Get the projected grid index
    int3 gridIndices = GetGridXYZIndices(o.position);
    int projectedGridIndex = GetProjectedGridIndexFromXYZ(gridIndices);

    // Initialize the new velocity from the old velocity
    float3 newVelocity = velocity;

    // Get the boid settings for this boid
    Boid2 b = boid_settings[o.boidIndex];
    
    // Get the zStep
    int zStep = numCellsPerAxis[0] * numCellsPerAxis[1];

    // Iterate through neighbors
    ObstacleDynamic other_o;
    for (int z = projectedGridIndex - zStep; z <= projectedGridIndex + zStep; z += zStep) {
        for (int y = z - numCellsPerAxis[0]; y <= z + numCellsPerAxis[0]; y += numCellsPerAxis[0]) {
            int start = grid_offsets[y - 2];
            int end = grid_offsets[y + 1];
            for (int i = start; i < end; i++) {
                uint otherId = rearranged_obstacles[i];
                other_o = obstacles_dynamic[otherId];
                // Reject if the other is not a boid
                if (other_o.isBoid == 0) continue;
                // Calculate the distance between the two boids
                float dist = distance(o.position, other_o.position);
                // If the distance is smaller than this boid's visual range, then we need to 
                if (dist > 0.0 && dist < b.visualRange) {
                    if (dist < b.innerRange) {
                        close += o.position - other_o.position;
                    }
                    center += other_o.position;
                    avgVel += obstacle_velocities[otherId];
                    neighbors++;
                }
            }
        }
    }

    //float distToTarget = distance(targetPos[0], boid.position) - targetRange;
    //if (distToTarget > 0.0) boidVelocities[id] += (targetPos[0] - boid.position) * targetBias * dt;

    if (neighbors > 0) {
        center /= neighbors;
        avgVel /= neighbors;

        newVelocity += (center - o.position) * (b.cohesionFactor * dt);
        newVelocity += (avgVel - velocity) * (b.alignmentFactor * dt);
    }

    newVelocity += close * (b.separationFactor * dt);
    float3 obstacleForce = float3(
        float(b.boundaryNormal[0])/(1024.0),
        float(b.boundaryNormal[1])/(1024.0),
        float(b.boundaryNormal[2])/(1024.0)
    );
    if (length(obstacleForce)>0.0) {
        float obsForceMag = clamp(length(obstacleForce),0.0,b.boundaryRange);
        newVelocity += normalize(obstacleForce) * b.boundaryRange * (obsForceMag/b.boundaryRange) * dt;
    }
    
    // Apply speed limits
    float speed = length(newVelocity);
    if (speed > b.maxSpeed) newVelocity = (newVelocity / speed) * b.maxSpeed;
    else if (speed < b.minSpeed) newVelocity = (newVelocity / speed) * b.minSpeed;

    // Keep in bounds
    if (o.position[0] < boid_bounds[0]) newVelocity[0] += dt * b.turnSpeed;
    else if (o.position[0] > boid_bounds[3]) newVelocity[0] -= dt * b.turnSpeed;
    if (o.position[1] < boid_bounds[1]) newVelocity[1] += dt * b.turnSpeed;
    else if (o.position[1] > boid_bounds[4]) newVelocity[1] -= dt * b.turnSpeed;
    if (o.position[2] < boid_bounds[2]) newVelocity[2] += dt * b.turnSpeed;
    else if (o.position[2] > boid_bounds[5]) newVelocity[2] -= dt * b.turnSpeed;
    

    // Set the new velocity
    velocity = newVelocity;
}

#pragma kernel IntegrateObstacles
[numthreads(16,1,1)]
void IntegrateObstacles(uint id : SV_DispatchThreadID) {
    if (id >= (uint)numObstacles) return;

    // Get the dynamic properties of the current obstacle
    ObstacleDynamic o_dynamic = obstacles_dynamic[id];
    // If the obstacle is a static one, return early
    if (o_dynamic.isStatic == 1) return;

    // Get the pressure force, but only if external forces are allowed
    float3 tForce = float3(0,0,0);
    float3 gForce = float3(0,0,0);
    if (o_dynamic.applyExternalForces == 1) {
        int3 translational_force = translational_forces[id];
        float3 tForce = float3(
            float(translational_force[0])/1024.0,
            float(translational_force[1])/1024.0,
            float(translational_force[2])/1024.0
        );
    }
    if (o_dynamic.applyGravity == 1) {
        gForce = g;
    }

    // Get the velocity of the obstacle
    float3 v = obstacle_velocities[id];

    // If the obstacle is a Boid, then it requires additional handling and calculation of the velocity.
    // The velocity is passed through as an inout variable and will be subsequently updated as a result after this function is executed
    if (o_dynamic.isBoid) {
        CalculateBoidDirection(o_dynamic, v, id);
    }

    // Apply the resulting forces at a delta time, and then integrate the position
    float3 acceleration = gForce + (tForce / o_dynamic.density);
    v += acceleration * dt;
    o_dynamic.position += v * dt;

    // return
    obstacle_velocities[id] = v;
    obstacles_dynamic[id] = o_dynamic;
}

#pragma kernel CombineForces
[numthreads(64,1,1)]
void CombineForces(uint id : SV_DispatchThreadID) {
    if (id >= numParticles) return;
    // We do all the checks to get the relevant obstacle and further check if the obstacle even has a rigidbody or not.
    Projection p = projections[id];
    uint triangleID = p.triangleID;
    if (triangleID >= numTriangles) return;
    uint obstacleID = triangles_static[triangleID].obstacleIndex;
    if (obstacles_static[obstacleID].has_rb == 0) return;
    // We need to calculate translational and torque force.
    // For translational force, we merely find the net force. This is merely the net force from summing all forces from particles
    InterlockedAdd(translational_forces[obstacleID][0], (int)(p.particle_force[0] * 1024));
    InterlockedAdd(translational_forces[obstacleID][1], (int)(p.particle_force[1] * 1024));
    InterlockedAdd(translational_forces[obstacleID][2], (int)(p.particle_force[2] * 1024));
    // For torque forces, we need the center of mass and calculate the cross product of the force and the relative vector from the center of mass to the position the force is applied
    /*
    float3 com = obstacles_dynamic[obstacleID].centerOfMass;
    float3 torque = cross((p.position - com),p.particle_force);
    InterlockedAdd(torque_forces[obstacleID][0], (int)(torque[0] * 1024));
    InterlockedAdd(torque_forces[obstacleID][1], (int)(torque[1] * 1024));
    InterlockedAdd(torque_forces[obstacleID][2], (int)(torque[2] * 1024));
    */
    //translational_forces[obstacleID] += projections[id].particle_force;
}