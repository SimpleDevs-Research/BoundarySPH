// ====================== //
// ===== PRIMITIVES ===== //
// ====================== //

/// Represents the STATIC properties of an obstacle. This includes the vertex, triangle, and edge indices.
struct ObstacleStatic {
    uint index;                 // Ref. index inside the obstacles arrays.
    uint2 vs;                   // [0] = starting index in the vertices arrays, [1] = the number of vertices.
    uint2 ts;                   // [0] = starting index in the triangles arrays, [1] = the number of triangles.
    uint2 es;                   // [0] = starting index in the edges arrays, [1] = the number of edges.
    float mass;                 // The mass of the obstacle. Considered a "static" variable because mass doesn't change.
    uint has_rb;
};

/// Represents the DYNAMIC properties of an obstacle that change during the update lop.
struct ObstacleDynamic {
    uint index;                  // Ref. index inside the obstacles arrays.
    float3 position;            // The world-space position of the transform.
    float4 rotation;            // The world-space rotation of the transform.
    float3 scale;               // The world-space scale of the transform. Typically via `Transform.LossyScale`.
    float3 lowerBound;          // The lower boundary position of this obstacle's bounding box.
    float3 upperBound;          // The upper boundary position of this obstacle's bounding box.
    float3 centerOfMass;
    float frictionCoefficient;  // The amount of friction the object is meant to exhibit on particles.
    uint checkObstacleBounds;
    uint checkTriangleBounds;
    uint hasChanged;             // A boolean indicator to determine if this obstacle had transformed in some way between the previous and current frame.
};

/// Represents the STATIC properties of each vertex. These values do not change at any point after the pre-processing stage.
struct VertexStatic {
    uint obstacleIndex;         // Ref. index to its parent obstacle in the obstacles arrays.
    float3 localPosition;       // The position of the vertex relative to the local space of the mesh. This will never change.
    float3 localNormal;      // The local endpoint of the 3D normal vector if starting from `localPosition`
};
/// Represents the DYNAMIC properties of each vertex. These values have to be updated if the parent obstacle has been transformed between the previous and current frames.
struct VertexDynamic {
    uint obstacleIndex;         // Ref. index to its parent obstacle in the obstacles arrays.
    float3 position;            // The current world-space position of this vertex.
    float3 normal;              // The current world-space, 3D normal vector of this vertex.
    float3 force;               // The calculated force based on the current velocity and previous velocity, which is F=m*(v/t)
};

/// Represents the STATIC properties of each triangle. These values never change after the pre-processing stage
struct TriangleStatic {
    uint obstacleIndex;     // Ref. index to its parent obstacle in the obstacles arrays.
    uint3 vertices;         // v1,v2,v3 - The indices of the three vertices of this triangle, referencing values in the vertices arrays. Organized in order of v1,v2,v3.
    float3 angles;          // v1,v2,v3 - The angles of each vertex. Used as weights in the calculation of the 3D normal vectors for each vertex. Organized in order of v1,v2,v3.
    uint3 edges;            // v1v2,v1v3,v2v3 - The indices of the three edges of this triangle, referencing values in the edges array. Organized in order of v1v2,v1v3,v2v3.
    float3 localCenter;     // The local-space centroid of the triangle.
    float3 localNormal;     // The local endpoint of the 3D normal vector if starting from `localCenter`
};
/// Represents the DYNAMIC properties of each triangle. These values are updated whenever the parent object is transformed between the previous and current frames.
struct TriangleDynamic {
    uint obstacleIndex;     // Ref. index to its parent obstacle in the obstacles arrays.
    float3 center;          // The world-space centroid of the triangle, defined by calculating the average of the world-space positions of each vertex.
    float3 normal;          // The world-space face normal vector of the triangle, calculated as the cross product of two edges v1v2 and v1v3
    float d;                // The signed distance of the plane to the origin (0,0,0). Needed to calculate the projection points onto the plane defined by this triangle.
    float3 v1v2n;           // The world-space 2D normal vector of the v1v2 edge.
    float3 v1v3n;           // The world-space 2D normal vector of the v1v3 edge.
    float3 v2v3n;           // The world-space 2D normal vector of the v2v3 edge.
    float3 lowerBound;      // The lower boundary position of this triangle's bounding box.
    float3 upperBound;      // The upper boundary position of this triangle's bounding box.
};

/// Represents the STATIC properties of each edge. These values will never change after the pre-processing stage.
struct EdgeStatic {
    uint obstacleIndex;     // Ref. index to its parent obstacle in the obstacles arrays.
    uint2 vertices;         // The indices of the two vertices of this edge, referencing values in the vertices arrays. Order is typically ascending in nature.
    uint2 triangles;        // The indices of the two triangles of this edge, referencing values in the triangles arrays. Order is not important.
    float3 midpoint;        // The middle point on the edge between the two vertices.
    float3 localNormal;  // The local-space endpoint of the 3D normal vector of the edge, if starting from the local midpoint of the edge line.
};

// Represents a fluid particle in the simulation
struct Particle {
    float3 position;
    float3 force;
};
struct Projection {
    uint triangleID;
    float3 projection;
    float3 position;
    float3 normal;
    float3 particle_force;      // The force exerted inward by the particle
    float3 external_force;      // The force exerted outward by the boundary due to velocity
    int counter;
    float frictionCoefficient;

    float3 e1;
    float3 e2;
    float3 e1_2DN;
    float3 e2_2DN;
    float3 e1_3DN;
    float3 e2_3DN;
};

// ============================ //
// ===== HELPER FUNCTIONS ===== //
// ============================ //

// https://answers.unity.com/questions/372371/multiply-quaternion-by-vector3-how-is-done.html
float3 RotMultVec3(float4 quat, float3 vec){
    float num = quat[0] * 2.0;
    float num2 = quat[1] * 2.0;
    float num3 = quat[2] * 2.0;
    float num4 = quat[0] * num;
    float num5 = quat[1] * num2;
    float num6 = quat[2] * num3;
    float num7 = quat[0] * num2;
    float num8 = quat[0] * num3;
    float num9 = quat[1] * num3;
    float num10 = quat[3] * num;
    float num11 = quat[3] * num2;
    float num12 = quat[3] * num3;

    float x = (1.0 - (num5 + num6)) * vec[0] + (num7 - num12) * vec[1] + (num8 + num11) * vec[2];
    if (abs(x) < 0.000000000001) x = 0;
    float y = (num7 + num12) * vec[0] + (1.0 - (num4 + num6)) * vec[1] + (num9 - num10) * vec[2];
    if (abs(y) < 0.000000000001) y = 0;
    float z = (num8 - num11) * vec[0] + (num9 + num10) * vec[1] + (1.0 - (num4 + num5)) * vec[2];
    if (abs(z) < 0.000000000001) z = 0;
    return float3(x,y,z);
}
// https://forum.unity.com/threads/whats-the-math-behind-transform-transformpoint.107401/
float3 LocalPointToWorldPoint(float3 pos, float4 rot, float3 scale, float3 localPoint) {
    float3 s = float3(localPoint[0] * scale[0], localPoint[1] * scale[1], localPoint[2] * scale[2]);
    return RotMultVec3(rot, s) + pos;
}
int PointInsideBound(float3 position, float3 lowerBounds, float3 upperBounds) {
    if (
        lowerBounds[0] <= position[0] && position[0] <= upperBounds[0]
        && lowerBounds[1] <= position[1] && position[1] <= upperBounds[1] 
        && lowerBounds[2] <= position[2] && position[2] <= upperBounds[2]    
    ) return 1;
    return 0;
}

// ===================== //
// ===== VARIABLES ===== //
// ===================== //

uint numObstacles;
uint numVertices;
uint numTriangles;
uint numEdges;

uint numParticles;
float particleRenderRadius;

float dt;                       // delta time - The time difference between frames.

StructuredBuffer<ObstacleStatic> obstacles_static;
RWStructuredBuffer<ObstacleDynamic> obstacles_dynamic;
StructuredBuffer<VertexStatic> vertices_static;
RWStructuredBuffer<VertexDynamic> vertices_dynamic;
StructuredBuffer<TriangleStatic> triangles_static;
RWStructuredBuffer<TriangleDynamic> triangles_dynamic;
StructuredBuffer<EdgeStatic> edges_static;
RWStructuredBuffer<float3> edges_dynamic;
RWStructuredBuffer<int3> translational_forces;
RWStructuredBuffer<int3> torque_forces;

RWStructuredBuffer<Particle> particles;
RWStructuredBuffer<Projection> projections;

#pragma kernel ResetVertexForces
[numthreads(64,1,1)]
void ResetVertexForces(uint id : SV_DispatchThreadID) {
    if (id >= numVertices) return;
    vertices_dynamic[id].force = float3(0,0,0);
}

#pragma kernel UpdateVertices
[numthreads(16,1,1)]
void UpdateVertices(uint id : SV_DispatchThreadID) {
    if (id >= numObstacles) return;
    
    ObstacleDynamic o_dynamic = obstacles_dynamic[id];
    if (o_dynamic.hasChanged == 0) return;

    ObstacleStatic o_static = obstacles_static[id];
    VertexStatic v_static;
    VertexDynamic v_dynamic;
    float3 worldPosition;
    for(uint i = o_static.vs[0]; i < o_static.vs[0]+o_static.vs[1]; i++) {
        v_static = vertices_static[i];
        v_dynamic = vertices_dynamic[i];        
        worldPosition = LocalPointToWorldPoint(o_dynamic.position, o_dynamic.rotation, o_dynamic.scale, v_static.localPosition);
        // Update the exertion force the vertex will push onto particles.  Calculated first before the position is updated
        v_dynamic.force = o_static.mass * (worldPosition - v_dynamic.position)/dt;
        // Update the world position of the current vertex
        v_dynamic.position = worldPosition;
        // Update the world normal of the current vertex
        v_dynamic.normal = normalize(RotMultVec3(o_dynamic.rotation, v_static.localNormal));
        // Upate our entry in Vertices_Dynamic
        vertices_dynamic[i] = v_dynamic;
        // Update the bounds of our object
        o_dynamic.lowerBound[0] = min(o_dynamic.lowerBound[0], v_dynamic.position[0]-particleRenderRadius);
        o_dynamic.lowerBound[1] = min(o_dynamic.lowerBound[1], v_dynamic.position[1]-particleRenderRadius);
        o_dynamic.lowerBound[2] = min(o_dynamic.lowerBound[2], v_dynamic.position[2]-particleRenderRadius);
        o_dynamic.upperBound[0] = max(o_dynamic.upperBound[0], v_dynamic.position[0]+particleRenderRadius);
        o_dynamic.upperBound[1] = max(o_dynamic.upperBound[1], v_dynamic.position[1]+particleRenderRadius);
        o_dynamic.upperBound[2] = max(o_dynamic.upperBound[2], v_dynamic.position[2]+particleRenderRadius);
    }
    obstacles_dynamic[id] = o_dynamic;
    /*
    if (id >= numVertices) return;
    
    // References
    VertexStatic v_static = vertices_static[id];
    VertexDynamic v_dynamic = vertices_dynamic[id];
    ObstacleStatic o_static = obstacles_static[v_dynamic.obstacleIndex];
    ObstacleDynamic o_dynamic = obstacles_dynamic[v_dynamic.obstacleIndex];
    // Only update if the obstacle needs to be updated
    if (o_dynamic.hasChanged == 0) return;
    
    // Convert into world position
    float3 worldPosition = LocalPointToWorldPoint(o_dynamic.position, o_dynamic.rotation, o_dynamic.scale, v_static.localPosition);
    // Update the world position of the current vertex
    v_dynamic.position = worldPosition;
    // Update the world normal of the current vertex
    v_dynamic.normal = normalize(RotMultVec3(o_dynamic.rotation, v_static.localNormal));

    // Upate our entry in Vertices_Dynamic
    vertices_dynamic[id] = v_dynamic;    
    */
}

#pragma kernel UpdateEdges
[numthreads(64,1,1)]
void UpdateEdges(uint id : SV_DispatchThreadID) {
    if (id >= numEdges) return;
    
    // References
    EdgeStatic e_static         = edges_static[id];
    ObstacleDynamic o_dynamic   = obstacles_dynamic[e_static.obstacleIndex];
    
    // Update only if the current object has changed
    if (o_dynamic.hasChanged == 0) return;
    edges_dynamic[id] = normalize(RotMultVec3(o_dynamic.rotation,e_static.localNormal));
}

#pragma kernel UpdateTriangles
[numthreads(64,1,1)]
void UpdateTriangles(uint id : SV_DispatchThreadID) {
    if (id >= numTriangles) return;
        
    // References
    TriangleStatic t_static     = triangles_static[id];
    TriangleDynamic t_dynamic   = triangles_dynamic[id];
    ObstacleDynamic o_dynamic   = obstacles_dynamic[t_dynamic.obstacleIndex];
    ObstacleStatic o_static     = obstacles_static[t_dynamic.obstacleIndex];
    
    // Skip if no need to update
    if (o_dynamic.hasChanged == 0) return;
    
    // Getting updated vertex positions
    VertexDynamic v1f = vertices_dynamic[o_static.vs[0] + t_static.vertices[0]];
    VertexDynamic v2f = vertices_dynamic[o_static.vs[0] + t_static.vertices[1]];
    VertexDynamic v3f = vertices_dynamic[o_static.vs[0] + t_static.vertices[2]];
    float3 v1 = v1f.position;
    float3 v2 = v2f.position;
    float3 v3 = v3f.position;
    
    // Updating center
    t_dynamic.center = LocalPointToWorldPoint(o_dynamic.position, o_dynamic.rotation, o_dynamic.scale, t_static.localCenter);
    // Updating normal
    t_dynamic.normal = normalize(RotMultVec3(o_dynamic.rotation, t_static.localNormal));
    // Updating d
    t_dynamic.d = dot(-1.0 * t_dynamic.center, t_dynamic.normal);
    
    // Update lowerBound and upperBound;
    t_dynamic.lowerBound = float3(
        min(min(v1[0],v2[0]),v3[0]) - (particleRenderRadius*2),
        min(min(v1[1],v2[1]),v3[1]) - (particleRenderRadius*2),
        min(min(v1[2],v2[2]),v3[2]) - (particleRenderRadius*2)
    );
    t_dynamic.upperBound = float3(
        max(max(v1[0],v2[0]),v3[0]) + (particleRenderRadius*2),
        max(max(v1[1],v2[1]),v3[1]) + (particleRenderRadius*2),
        max(max(v1[2],v2[2]),v3[2]) + (particleRenderRadius*2)
    );
    
    // updating v1v2n, v1v3n, v2v3n
    float3 v1v2 = v2 - v1;
    float3 v1c = t_dynamic.center - v1;
    float3 v2v3 = v3 - v2;
    float3 v2c = t_dynamic.center - v2;
    float3 v1v3 = v3-v1;
    t_dynamic.v1v2n = -normalize(v1c - (dot(v1c,v1v2)/dot(v1v2,v1v2))*v1v2);
    t_dynamic.v1v3n = -normalize(v1c - (dot(v1c,v1v3)/dot(v1v3,v1v3))*v1v3);
    t_dynamic.v2v3n = -normalize(v2c - (dot(v2c,v2v3)/dot(v2v3,v2v3))*v2v3);

    // Update our entry in the array
    triangles_dynamic[id] = t_dynamic;
}

#pragma kernel ResetHasChanged
[numthreads(64,1,1)]
void ResetHasChanged(uint id : SV_DispatchThreadID) {
    if (id >= numObstacles) return;
    obstacles_dynamic[id].hasChanged = 0;
}

#pragma kernel ResetTempProjections
[numthreads(64,1,1)]
void ResetTempProjections(uint id : SV_DispatchThreadID) {
    if (id >= numParticles) return;
    Projection projection = projections[id];
    projection.triangleID = numTriangles;
    projection.projection = particles[id].position;
    projection.position = particles[id].position;
    projection.normal = float3(0,0,0);
    projection.particle_force = float3(0,0,0);
    projection.external_force = float3(0,0,0);
    projection.counter = 0;
    projection.frictionCoefficient = 0.0;

    projection.e1 = float3(0,0,0);
    projection.e2 = float3(0,0,0);
    projection.e1_2DN = float3(0,0,0);
    projection.e2_2DN = float3(0,0,0);
    projection.e1_3DN = float3(0,0,0);
    projection.e2_3DN = float3(0,0,0);

    projections[id] = projection;

    translational_forces[id] = int3(0,0,0);
    torque_forces[id] = int3(0,0,0);
}

int CheckVoroniRegions(
        float3 proj,                    // the projection of 3D point onto the 2D plane
        float3 v, float3 vN,            // the comparison vertex of the triangle + its normal
        float3 e1, float3 e2,           // The two edges connected to v1
        float3 e1_2DN, float3 e2_2DN,   // The 2D normals of the two edges
        float3 e1_3DN, float3 e2_3DN,   // The 3D normals of the two edges
        float3 tri_N,                    // The normal of the triangle itself
        float threshold,                // The threshold value for edge comparison
        out float3 closestPoint,
        out float3 closestNormal
) {
    // Determine vector from vertex to position
    float3 v_to_p = proj - v;
    
    // Now, the position is closest to the vertex if the dot(edge1 , v_to_p) <= 0 AND dot(edge2, v_to_p) <= 0
    float d1 = dot(e1, v_to_p);
    float d2 = dot(e2, v_to_p);
    if (d1 <= 0 && d2 <= 0) {
        closestPoint = v;
        closestNormal = vN;
        // We need to check if the point is actually the vertex 
        //if (d1 == 0 && d2 == 0) return 1;
        //return 0;
        return 1;
    }
    
    // At this point, we need to check if position is closer to edge1 or edge2. This is via dot product comparison
    // We introduce a "threshold" because float points are finicky and there's a margin for error w.r.t. if the projection is exactly on the line
    float d3 = dot(e1_2DN, v_to_p);
    if (d3 >= threshold) {
        closestPoint = v+ e1 * abs((d1 / dot(e1, e1)));
        closestNormal = e1_3DN;
        //if (d3 == threshold) return 1;
        //return 0;
        return 2;
    }
    float d4 = dot(e2_2DN, v_to_p);
    if (d4 >= threshold) {
        closestPoint = v + e2 * abs((d2 / dot(e2, e2)));
        closestNormal = e2_3DN;
        //if (d4 == threshold) return 1;
        //return 0;
        return 2;
    }

    // At this point, the point is inside the triangle. No need to reproject
    closestPoint = proj;
    closestNormal = tri_N;
    //return 1;
    return 3;
}
#pragma kernel CheckForProjection
[numthreads(16,1,1)]
void CheckForProjection(uint id : SV_DispatchThreadID ) {
    if (id >= numParticles) return;

    // References
    Particle particle = particles[id];
    Projection projection = projections[id];

    ObstacleStatic o_static;
    ObstacleDynamic o_dynamic;
    for(uint oi = 0; oi < numObstacles; oi++) {
        o_dynamic = obstacles_dynamic[oi];
        
        // Skip if the particle isn't in the boundaries of this obstacle
        if (o_dynamic.checkObstacleBounds == 1 && PointInsideBound(particle.position, o_dynamic.lowerBound, o_dynamic.upperBound) == 0) continue;

        // grab the static obstacle
        o_static = obstacles_static[oi];
        
        // Iterate through the vertices
        for(uint i = o_static.ts[0]; i < o_static.ts[0] + o_static.ts[1]; i++) {
            TriangleDynamic tri_dynamic = triangles_dynamic[i];
    
            // Check if the particle is inside the triangle's boundaries
            if (o_dynamic.checkTriangleBounds == 1 && PointInsideBound(particle.position, tri_dynamic.lowerBound, tri_dynamic.upperBound) == 0) continue;
    
            // More references
            TriangleStatic tri_static = triangles_static[i];
            VertexDynamic v1 = vertices_dynamic[o_static.vs[0] + tri_static.vertices[0]];
            VertexDynamic v2 = vertices_dynamic[o_static.vs[0] + tri_static.vertices[1]];
            VertexDynamic v3 = vertices_dynamic[o_static.vs[0] + tri_static.vertices[2]];

            // At this point, we need to project the particle's position onto the plane defined by this triangle.
            // To calculate this projection, we grab the normal vector of the triangle and use that as our direction
            // Normally, we need to check if the vector from the particle's position to the centroid of the plane is parallal to the normal vector direction...
            //   ... however, in this case, we don't have to do that. This is because the direction we're using to project the particle position will always be orthogonal to the plane
            float3 dir = normalize(sign(dot(tri_dynamic.normal, tri_dynamic.center - particle.position)) * tri_dynamic.normal);    
            // We need to project the point onto the plane formed by this triangle
            float dist_from_point_to_plane = -(dot(tri_dynamic.normal, particle.position) + tri_dynamic.d) / dot(tri_dynamic.normal, dir);
            float3 proj1 = particle.position + dist_from_point_to_plane * dir;

            float3 closestVertexPosition = v1.position;
            float3 closestVertexNormal = v1.normal;
            float3 edge1 = v2.position - v1.position;
            float3 edge2 = v3.position - v1.position;
            float3 e1_2DN = tri_dynamic.v1v2n;
            float3 e2_2DN = tri_dynamic.v1v3n;
            float3 e1_3DN = edges_dynamic[o_static.es[0] + tri_static.edges[0]];
            float3 e2_3DN = edges_dynamic[o_static.es[0] + tri_static.edges[1]];
            float denom, u, v, distfinal;
            float3 c, innermostPoint;
            
            if (distance(particle.position, v2.position) < distance(particle.position, closestVertexPosition)) {
                closestVertexPosition = v2.position;
                closestVertexNormal = v2.normal;
                edge1 = v1.position - v2.position;
                edge2 = v3.position - v2.position;
                e1_2DN = tri_dynamic.v1v2n;
                e2_2DN = tri_dynamic.v2v3n;
                e1_3DN = edges_dynamic[o_static.es[0] + tri_static.edges[0]];
                e2_3DN = edges_dynamic[o_static.es[0] + tri_static.edges[2]];
            }
            if (distance(particle.position, v3.position) < distance(particle.position, closestVertexPosition)) {
                closestVertexPosition = v3.position;
                closestVertexNormal = v3.normal;
                edge1 = v1.position - v3.position;
                edge2 = v2.position - v3.position;
                e1_2DN = tri_dynamic.v1v3n;
                e2_2DN = tri_dynamic.v2v3n;
                e1_3DN = edges_dynamic[o_static.es[0] + tri_static.edges[1]];
                e2_3DN = edges_dynamic[o_static.es[0] + tri_static.edges[2]];
            }

            float3 final_proj_position, final_proj_normal;
            int isInTriangle = CheckVoroniRegions(
                proj1,                          // The projection of the particle position onto the plane
                closestVertexPosition, closestVertexNormal,   // The closest vertex position + its 3D normal
                edge1, edge2,                   // The two edges connected to the closest vertex
                normalize(e1_2DN), normalize(e2_2DN),                 // The 2D normals of the two connected edges
                normalize(e1_3DN), normalize(e2_3DN),                 // The 3D normals of the two connected edges
                normalize(tri_dynamic.normal),             // The triangle normal
                0.05,                            // The threshold for overlap
                final_proj_position,        // reference to the projection position
                final_proj_normal           // reference the projection normal
            );

            if (projection.counter == 0 || distance(final_proj_position,particle.position) < distance(projection.position, particle.position)) {
                projection.triangleID = i;
                projection.projection = proj1;
                projection.position = final_proj_position;
                projection.normal = final_proj_normal;

                // We have to calculate the force at this point
                denom = dot(projection.normal, projection.normal);
                c = cross(v3.position - v2.position, final_proj_position - v2.position);
                u = dot(projection.normal, c) / denom;
                c = cross(v1.position - v3.position, final_proj_position - v3.position);
                v = dot(projection.normal, c) / denom;
                projection.external_force = (u * v1.force) + (v * v2.force) + ((1-u-v) * v3.force);
                // We also have to calculate the amount of force exerted by the particle.
                // For now, we just calculate the orthogonal force based on the particle's current force
                // To calculate the force component along the normal vector, we:
                // 1) detect if the particle is within range or is intersecting with the triangle
                // 2) if so, perform the follwing: dot(normal,particle force) / length(normal)
                // since the normal is normalized, it'll just be 1. So we just calcualte dot(normal, particle force)
                distfinal = distance(final_proj_position, particle.position);
                innermostPoint = particle.position - final_proj_normal * particleRenderRadius;
                //projection.particle_force = dot(-final_proj_normal, particle.force) * (-final_proj_normal);
                
                if (
                    distfinal <= particleRenderRadius 
                    || dot(final_proj_position - innermostPoint, final_proj_normal) >= 0.0
                ) {
                    projection.particle_force = dot(-final_proj_normal, particle.force) * (-final_proj_normal);
                } else {
                    projection.particle_force = float3(0,0,0);
                }
                

                projection.counter = isInTriangle;
                projection.frictionCoefficient = o_dynamic.frictionCoefficient;

                projection.e1 = edge1;
                projection.e2 = edge2;
                projection.e1_2DN = e1_2DN;
                projection.e2_2DN = e2_2DN;
                projection.e1_3DN = e1_3DN;
                projection.e2_3DN = e2_3DN;
            }
        }
    }
    
    /*
    for(uint i = 0; i < numTriangles; i++) {
        TriangleDynamic tri_dynamic = triangles_dynamic[i];
    
        // Check if the particle is inside the triangle's boundaries
        //if (PointInsideBound(particle.position, tri_dynamic.lowerBound, tri_dynamic.upperBound) == 0) continue;
    
        // More references
        TriangleStatic tri_static = triangles_static[i];
        ObstacleStatic o_static = obstacles_static[tri_static.obstacleIndex];
        ObstacleDynamic o_dynamic = obstacles_dynamic[tri_static.obstacleIndex];
        VertexDynamic v1 = vertices_dynamic[o_static.vs[0] + tri_static.vertices[0]];
        VertexDynamic v2 = vertices_dynamic[o_static.vs[0] + tri_static.vertices[1]];
        VertexDynamic v3 = vertices_dynamic[o_static.vs[0] + tri_static.vertices[2]];

        // At this point, we need to project the particle's position onto the plane defined by this triangle.
        // To calculate this projection, we grab the normal vector of the triangle and use that as our direction
        // Normally, we need to check if the vector from the particle's position to the centroid of the plane is parallal to the normal vector direction...
        //   ... however, in this case, we don't have to do that. This is because the direction we're using to project the particle position will always be orthogonal to the plane
        float3 dir = normalize(sign(dot(tri_dynamic.normal, tri_dynamic.center - particle.position)) * tri_dynamic.normal);    
        // We need to project the point onto the plane formed by this triangle
        float dist_from_point_to_plane = -(dot(tri_dynamic.normal, particle.position) + tri_dynamic.d) / dot(tri_dynamic.normal, dir);
        float3 proj1 = particle.position + dist_from_point_to_plane * dir;

        float3 closestVertexPosition = v1.position;
        float3 closestVertexNormal = v1.normal;
        float3 edge1 = v2.position - v1.position;
        float3 edge2 = v3.position - v1.position;
        float3 e1_2DN = tri_dynamic.v1v2n;
        float3 e2_2DN = tri_dynamic.v1v3n;
        float3 e1_3DN = edges_dynamic[o_static.es[0] + tri_static.edges[0]];
        float3 e2_3DN = edges_dynamic[o_static.es[0] + tri_static.edges[1]];
        if (distance(particle.position, v2.position) < distance(particle.position, closestVertexPosition)) {
            closestVertexPosition = v2.position;
            closestVertexNormal = v2.normal;
            edge1 = v1.position - v2.position;
            edge2 = v3.position - v2.position;
            e1_2DN = tri_dynamic.v1v2n;
            e2_2DN = tri_dynamic.v2v3n;
            e1_3DN = edges_dynamic[o_static.es[0] + tri_static.edges[0]];
            e2_3DN = edges_dynamic[o_static.es[0] + tri_static.edges[2]];
        }
        if (distance(particle.position, v3.position) < distance(particle.position, closestVertexPosition)) {
            closestVertexPosition = v3.position;
            closestVertexNormal = v3.normal;
            edge1 = v1.position - v3.position;
            edge2 = v2.position - v3.position;
            e1_2DN = tri_dynamic.v1v3n;
            e2_2DN = tri_dynamic.v2v3n;
            e1_3DN = edges_dynamic[o_static.es[0] + tri_static.edges[1]];
            e2_3DN = edges_dynamic[o_static.es[0] + tri_static.edges[2]];
        }

        float3 final_proj_position, final_proj_normal;
        int isInTriangle = CheckVoroniRegions(
            proj1,                          // The projection of the particle position onto the plane
            closestVertexPosition, closestVertexNormal,   // The closest vertex position + its 3D normal
            edge1, edge2,                   // The two edges connected to the closest vertex
            normalize(e1_2DN), normalize(e2_2DN),                 // The 2D normals of the two connected edges
            normalize(e1_3DN), normalize(e2_3DN),                 // The 3D normals of the two connected edges
            normalize(tri_dynamic.normal),             // The triangle normal
            0.05,                            // The threshold for overlap
            final_proj_position,        // reference to the projection position
            final_proj_normal           // reference the projection normal
        );

        if (projection.counter == 0 || distance(final_proj_position,particle.position) < distance(projection.position, particle.position)) {
            projection.triangleID = i;
            projection.projection = proj1;
            projection.position = final_proj_position;
            projection.normal = final_proj_normal;
            projection.counter = isInTriangle;
            projection.frictionCoefficient = o_dynamic.frictionCoefficient;

            projection.e1 = edge1;
            projection.e2 = edge2;
            projection.e1_2DN = e1_2DN;
            projection.e2_2DN = e2_2DN;
            projection.e1_3DN = e1_3DN;
            projection.e2_3DN = e2_3DN;
        }
    }
    */

    projections[id] = projection;
}

#pragma kernel CombineForces
[numthreads(64,1,1)]
void CombineForces(uint id : SV_DispatchThreadID) {
    if (id >= numParticles) return;
    // We do all the checks to get the relevant obstacle and further check if the obstacle even has a rigidbody or not.
    Projection p = projections[id];
    uint triangleID = p.triangleID;
    if (triangleID >= numTriangles) return;
    uint obstacleID = triangles_static[triangleID].obstacleIndex;
    if (obstacles_static[obstacleID].has_rb == 0) return;
    // We need to calculate translational and torque force.
    // For translational force, we merely find the net force. This is merely the net force from summing all forces from particles
    InterlockedAdd(translational_forces[obstacleID][0], (int)(p.particle_force[0] * 1024));
    InterlockedAdd(translational_forces[obstacleID][1], (int)(p.particle_force[1] * 1024));
    InterlockedAdd(translational_forces[obstacleID][2], (int)(p.particle_force[2] * 1024));
    // For torque forces, we need the center of mass and calculate the cross product of the force and the relative vector from the center of mass to the position the force is applied
    float3 com = obstacles_dynamic[obstacleID].centerOfMass;
    float3 torque = cross((p.position - com),p.particle_force);
    InterlockedAdd(torque_forces[obstacleID][0], (int)(torque[0] * 1024));
    InterlockedAdd(torque_forces[obstacleID][1], (int)(torque[1] * 1024));
    InterlockedAdd(torque_forces[obstacleID][2], (int)(torque[2] * 1024));
    //translational_forces[obstacleID] += projections[id].particle_force;
}