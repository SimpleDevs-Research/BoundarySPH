// Includes. Incorporating Sebastian's code
#include "./FluidMaths3D.hlsl"
#include "./SpatialHash3D.hlsl"

// Constants. Are only updated once and never updated again
uint numParticles;
float epsilon;
float pi;


// Changeable Variables. These may be updated as the simulation runs through its course.
float particleMass;
float deltaTime;
float3 external_force;              // gravity
float smoothingRadius;                // h
float rest_density;                 // p_0
float viscosity_influence;          // mu
float pressure_influence;           // bulk modulus
float near_pressure_influence;
float damping_effect;

// Important Structs
struct Particle {
    float3 position;
    float3 force;
    int render;
};
struct Projection {
	uint obstacle_id;
    uint triangleID;
    float3 projection;
    float3 position;
    float3 normal;
    float3 particle_force;      // force exerted into the boundary by the particle
    float3 external_force;      // force exerted toward the particle by the boundary due to velocity
    int counter;
    float frictionCoefficient;
    float restitutionCoefficient;

    float3 e1;
    float3 e2;
    float3 e1_2DN;
    float3 e2_2DN;
    float3 e1_3DN;
    float3 e2_3DN;
};
struct Vertex {
    uint obstacleIndex;
    float3 position;
    float3 normal;
};
struct Edge {
	uint obstacleIndex;
    uint2 vertices;
    uint2 triangles;
    float3 midpoint;
    float3 normal;     
};
struct Triangle {
    uint obstacleIndex;
    uint3 vertices;
    float3 angles;
    uint3 edges;
    float3 center;
    float3 normal;
    float distance_to_center;
    float3 v1v2n;
    float3 v2v3n;
    float3 v1v3n;
};
struct Obstacle {
    uint index;
    float friction_coefficient;
    float restitution_coefficient;
    uint2 vertex_range;      // [0] = starting index in global vertices, [1] = # of vertices associated with this obstacle. _+
    uint2 triangles_range;   // [0] = starting index in global triangles, [1] = # of vertices associated with this obstacle.
    uint2 edges_range;       // [0] = starting index in global edges, [1] = # of edges associated with this obstacle
};

// Buffers
RWStructuredBuffer<Particle> particles;
RWStructuredBuffer<float3> predictedPositions;
RWStructuredBuffer<float3> velocities;
RWStructuredBuffer<float> velocity_magnitudes;
RWStructuredBuffer<float> densities;
RWStructuredBuffer<float> near_densities;
RWStructuredBuffer<float> pressures;
RWStructuredBuffer<float> near_pressures;
RWStructuredBuffer<Projection> obstacleForces;
RWStructuredBuffer<uint3> spatialIndices;   // used for spatial hashing. We do not touch these. EVER.
RWStructuredBuffer<uint> spatialOffsets;    // used for spatial hashing. We do not touch these. EVER.
// These Buffers are important for obstacle interactions
RWStructuredBuffer<Obstacle> obstacles;
RWStructuredBuffer<Vertex> vertices;
RWStructuredBuffer<Edge> edges;
RWStructuredBuffer<Triangle> trianges;
RWStructuredBuffer<float4x4> worldpos_to_local_matrices;
RWStructuredBuffer<float4x4> worlddir_to_local_matrices;
RWStructuredBuffer<float4x4> localpos_to_world_matrices;
RWStructuredBuffer<float4x4> localdir_to_world_matrices;


#pragma kernel UpdateExternalForces
[numthreads(256,1,1)]
void UpdateExternalForces(uint3 id : SV_DispatchThreadID) {
    // Don't run if we reach an ID that isn't part of our particles
    if (id.x >= numParticles) return;

	// Add external force (AKA gravity) to our particle's velocity
	velocities[id.x] += external_force * deltaTime;

	// Now here, we actually do something interesting: we actuallly make a PREDICTION of where the particle would be if no other influence were to affect the particle
    // The idea is that we would be performing SPH calculations on predictions of where a particle might be.
    // The benefit being that we don't actually move the particle yet - all particle movements are estimated prior, then we finally implement the translation at the way end.
	// The other thing is that we don't use `deltaTime` - instead, we use a different delta time. Based on both my and Sebastian's observations, predictions were more stable when a standard delta time was implemented.
    // No idea why this is. May need to look into it further. But if it works, it works.
    predictedPositions[id.x] = particles[id.x].position + velocities[id.x] * 1 / 120.0;
}

#pragma kernel UpdateSpatialHash
[numthreads(256,1,1)]
void UpdateSpatialHash(uint3 id : SV_DispatchThreadID) {
    // Don't run if we reach an ID that isn't part of our particles
    if (id.x >= numParticles) return;

	// I'll briefly explain what's going on here.
    // With SPH, we need some neighborhood search implementation to let particles optimize search times regarding which particles are likely to be close enough.
    // Instead of searching all other particles (making this step an n^n process), we optimize by having the particle search only the regional neighborhood around the particle.
    // Traditionally, we'd use grids and identify which particles were in each grid; then it became a simple matter of querying which grid cells were neighbors to our particle's grid cell...
    // ... then querying which particles were IN those neighboring cells, then performing any high-fidelity distance check. That's fine, and it's implemented here.
    // However, we can even FURTHER optimize this by implementing sorting of indexes when it comes to grid cell indices and particle indices in cells.
    // Kind of like instead of searching a messy drawer where you KNOW you put your favorite t-shirt but since it's disorganized you have to take some time to search, we can
    // optimize by sorting those t-shirts, so that you can more quickly identify which shirt is which. In thiscase, we use Bitonic Sort.

    // A much nicer description of this method is provided by Sebastian, who has done the legwork to describe everything about this process in detail. https://www.youtube.com/watch?v=rSKMYc1CQHE
    
    // Reset offsets
	spatialOffsets[id.x] = numParticles;

	// Update index buffer
	uint index = id.x;
	int3 cell = GetCell3D(predictedPositions[index], smoothingRadius);
	uint hash = HashCell3D(cell);
	uint key = KeyFromHash(hash, numParticles);
	spatialIndices[id.x] = uint3(index, hash, key);
}

/*
// Helper function: spiky kernel, power of 2
float SpikyKernelPow2(float dst, float radius) {
	if (dst < radius) {
		float scale = 15 / (2 * pi * pow(radius, 5));
		float v = radius - dst;
		return v * v * scale;
	}
	return 0;
}
float SpikyKernelPow3(float dst, float radius) {
	if (dst < radius) {
		float scale = 15 / (pi * pow(radius, 6));
		float v = radius - dst;
		return v * v * v * scale;
	}
	return 0;
}
*/

#pragma kernel UpdateDensity
[numthreads(256,1,1)]
void UpdateDensity(uint3 id : SV_DispatchThreadID) {
    // Don't run if we reach an ID that isn't part of our particles
    if (id.x >= numParticles) return;

    // Use the predicted position of the current particle
	float3 pos = predictedPositions[id.x];

    // We need the cell id
	int3 originCell = GetCell3D(pos, smoothingRadius);
	float sqrRadius = smoothingRadius * smoothingRadius;
    float radius3 = smoothingRadius * sqrRadius;
	float density = (315.0 * particleMass) / (64.0 * pi * radius3);
	float nearDensity = (315.0 * particleMass) / (64.0 * pi * radius3);

	// Neighbour search
	for (int i = 0; i < 27; i ++) {
		uint hash = HashCell3D(originCell + offsets3D[i]);
		uint key = KeyFromHash(hash, numParticles);
		uint currIndex = spatialOffsets[key];

		while (currIndex < numParticles)
		{
			uint3 indexData = spatialIndices[currIndex];
			currIndex ++;
			// Exit if no longer looking at correct bin
			if (indexData[2] != key) break;
			// Skip if hash does not match
			if (indexData[1] != hash) continue;

			uint neighbourIndex = indexData[0];
			float3 neighbourPos = predictedPositions[neighbourIndex];
			float3 offsetToNeighbour = neighbourPos - pos;
			float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

			// Skip if not within radius
			if (sqrDstToNeighbour > sqrRadius) continue;

			// Calculate density and near density
			float dst = sqrt(sqrDstToNeighbour);
			density += particleMass * SpikyKernelPow2(dst, smoothingRadius);
			nearDensity += particleMass * NearDensityKernel(dst, smoothingRadius);
		}
	}
	
	densities[id.x] = density;
    near_densities[id.x] = nearDensity;
}

float PressureFromDensity(float density) {
	return (density - rest_density) * pressure_influence;
}

float NearPressureFromDensity(float nearDensity) {
	return nearDensity * near_pressure_influence;
}

/*
float DerivativeSpikyPow3(float dst, float radius) {
	if (dst <= radius) {
		float scale = 45 / (pow(radius, 6) * PI);
		float v = radius - dst;
		return -v * v * scale;
	}
	return 0;
}

// 3d conversion: done
float DerivativeSpikyPow2(float dst, float radius) {
	if (dst <= radius) {
		float scale = 15 / (pow(radius, 5) * PI);
		float v = radius - dst;
		return -v * scale;
	}
	return 0;
}
*/

#pragma kernel UpdatePressure
[numthreads(256,1,1)]
void UpdatePressure(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numParticles) return;

	// Calculate pressure
	float density = densities[id.x];
	float densityNear = near_densities[id.x];
	float pressure = PressureFromDensity(density);
	float nearPressure = NearPressureFromDensity(densityNear);
	float3 pressureForce = 0;
	
	float3 pos = predictedPositions[id.x];
	int3 originCell = GetCell3D(pos, smoothingRadius);
	float sqrRadius = smoothingRadius * smoothingRadius;

	// Neighbour search
	for (int i = 0; i < 27; i ++)
	{
		uint hash = HashCell3D(originCell + offsets3D[i]);
		uint key = KeyFromHash(hash, numParticles);
		uint currIndex = spatialOffsets[key];

		while (currIndex < numParticles)
		{
			uint3 indexData = spatialIndices[currIndex];
			currIndex ++;
			// Exit if no longer looking at correct bin
			if (indexData[2] != key) break;
			// Skip if hash does not match
			if (indexData[1] != hash) continue;

			uint neighbourIndex = indexData[0];
			// Skip if looking at self
			if (neighbourIndex == id.x) continue;

			float3 neighbourPos = predictedPositions[neighbourIndex];
			float3 offsetToNeighbour = neighbourPos - pos;
			float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

			// Skip if not within radius
			if (sqrDstToNeighbour > sqrRadius) continue;

			// Calculate pressure force
			float densityNeighbour = densities[neighbourIndex];
			float nearDensityNeighbour = near_densities[neighbourIndex];
			float neighbourPressure = PressureFromDensity(densityNeighbour);
			float neighbourPressureNear = NearPressureFromDensity(nearDensityNeighbour);

			float sharedPressure = (pressure + neighbourPressure) / 2;
			float sharedNearPressure = (nearPressure + neighbourPressureNear) / 2;

			float dst = sqrt(sqrDstToNeighbour);
			float3 dir = dst > 0 ? offsetToNeighbour / dst : float3(0, 1, 0);

			pressureForce += dir * DerivativeSpikyPow2(dst, smoothingRadius) * sharedPressure / densityNeighbour;
			pressureForce += dir * DerivativeSpikyPow3(dst, smoothingRadius) * sharedNearPressure / nearDensityNeighbour;
		}
	}

	float3 acceleration = pressureForce / density;
	velocities[id.x] += acceleration * deltaTime;
    pressures[id.x] = pressure;
    near_pressures[id.x] = nearPressure;
}

/*
float SmoothingKernelPoly6(float dst, float radius) {
	if (dst < radius) {
		float scale = 315 / (64 * PI * pow(abs(radius), 9));
		float v = radius * radius - dst * dst;
		return v * v * v * scale;
	}
	return 0;
}
*/

#pragma kernel UpdateViscosity
[numthreads(256,1,1)]
void UpdateViscosity(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numParticles) return;
		
	float3 pos = predictedPositions[id.x];
	int3 originCell = GetCell3D(pos, smoothingRadius);
	float sqrRadius = smoothingRadius * smoothingRadius;

	float3 viscosityForce = 0;
	float3 velocity = velocities[id.x];

	// Neighbour search
	for (int i = 0; i < 27; i ++)
	{
		uint hash = HashCell3D(originCell + offsets3D[i]);
		uint key = KeyFromHash(hash, numParticles);
		uint currIndex = spatialOffsets[key];

		while (currIndex < numParticles)
		{
			uint3 indexData = spatialIndices[currIndex];
			currIndex ++;
			// Exit if no longer looking at correct bin
			if (indexData[2] != key) break;
			// Skip if hash does not match
			if (indexData[1] != hash) continue;

			uint neighbourIndex = indexData[0];
			// Skip if looking at self
			if (neighbourIndex == id.x) continue;

			float3 neighbourPos = predictedPositions[neighbourIndex];
			float3 offsetToNeighbour = neighbourPos - pos;
			float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

			// Skip if not within radius
			if (sqrDstToNeighbour > sqrRadius) continue;

			// Calculate viscosity
			float dst = sqrt(sqrDstToNeighbour);
			float3 neighbourVelocity = velocities[neighbourIndex];
			viscosityForce += (neighbourVelocity - velocity) * SmoothingKernelPoly6(dst, smoothingRadius);
		}
	}
	velocities[id.x] += viscosityForce * viscosity_influence * deltaTime;
}

/*
#pragma kernel UpdateProjections
[numthreads(256,1,1)]
void UpdateProjections(uint3 id : SV_DispatchThreadID) {
	if (id.x >= numParticles) return;
	// References
    Particle particle = particles[id];
    Projection projection = projections[id];
	// Rset the projection
	projection.counter = 0;
    
    for(uint oi = 0; oi < numObstacles; oi++) {
		float3 p = mul(worldpos_to_local_matrices[oi], particle.position);
        int meshobs_found = 0;
        float3 meshobs_closest_point = p;
        float meshobs_closest_distance = 0.0;
        float3 meshobs_closest_normal = float3(0,0,0);
		// Grab the current obstacle
        Obstacle o = obstacles[oi];
        // Iterate through the vertices
        for(uint i = o.triangles_range[0]; i < o.triangles_range[0] + o.triangles_range[1]; i++) {
            Triangle t = triangles[i];
            // More references
            Vertex v1 = vertices[o.vertex_range[0] + t.vertices[0]];
            Vertex v2 = vertices[o.vertex_range[0] + t.vertices[1]];
            Vertex v3 = vertices[o.vertex_range[0] + t.vertices[2]];

            // At this point, we need to project the particle's position onto the plane defined by this triangle.
            // To calculate this projection, we grab the normal vector of the triangle and use that as our direction
            // Normally, we need to check if the vector from the particle's position to the centroid of the plane is parallal to the normal vector direction...
            //   ... however, in this case, we don't have to do that. This is because the direction we're using to project the particle position will always be orthogonal to the plane
            float3 dir = normalize(sign(dot(t.normal, t.center - p)) * t.normal);
            // We need to project the point onto the plane formed by this triangle
            float dist_from_point_to_plane = -(dot(t.normal, p) + t.distance_to_center) / dot(t.normal, dir);
            float3 proj1 = p + dist_from_point_to_plane * dir;

            float3 closestVertexPosition = v1.position;
            float3 closestVertexNormal = v1.normal;
            float3 edge1 = v2.position - v1.position;
            float3 edge2 = v3.position - v1.position;
            float3 e1_2DN = t.v1v2n;
            float3 e2_2DN = t.v1v3n;
            float3 e1_3DN = edges[o.edges_range[0] + t.edges[0]];
            float3 e2_3DN = edges[o.edges_range[0] + t.edges[1]];
            float denom, u, v, distfinal;
            float3 c, innermostPoint, v1force, v2force, v3force;
            
            if (distance(p, v2.position) < distance(p, closestVertexPosition)) {
                closestVertexPosition = v2.position;
                closestVertexNormal = v2.normal;
                edge1 = v1.position - v2.position;
                edge2 = v3.position - v2.position;
                e1_2DN = t.v1v2n;
                e2_2DN = t.v2v3n;
                e1_3DN = edges[o.edges_range[0] + t.edges[0]];
                e2_3DN = edges[o.edges_range[0] + t.edges[2]];
            }
            if (distance(p, v3.position) < distance(p, closestVertexPosition)) {
                closestVertexPosition = v3.position;
                closestVertexNormal = v3.normal;
                edge1 = v1.position - v3.position;
                edge2 = v2.position - v3.position;
                e1_2DN = t.v1v3n;
                e2_2DN = t.v2v3n;
                e1_3DN = edges[o.edges_range[0] + t.edges[1]];
                e2_3DN = edges[o.edges_range[0] + t.edges[2]];
            }

            float3 final_proj_position;
            float3 final_proj_normal;
            int isInTriangle = CheckVoroniRegions(
                proj1,                          // The projection of the particle position onto the plane
                closestVertexPosition, closestVertexNormal,   // The closest vertex position + its 3D normal
                edge1, edge2,                   // The two edges connected to the closest vertex
                normalize(e1_2DN), normalize(e2_2DN),                 // The 2D normals of the two connected edges
                normalize(e1_3DN), normalize(e2_3DN),                 // The 3D normals of the two connected edges
                normalize(t.normal),             // The triangle normal
                0.05,                            // The threshold for overlap
                final_proj_position,        // reference to the projection position
                final_proj_normal           // reference the projection normal
            );

            // Check if the particle is either in range of the boundary triangle or if it's underneath
            distfinal = distance(final_proj_position, p);
            //innermostPoint = particle.position - final_proj_normal * particleRenderRadius;
			innermostPoint = particle.position;

            if (
                    projection.counter == 0 
                    || distfinal < distance(projection.position, p)
            ) {
				projection.obstacle_id = oi;
                projection.triangleID = i;
                projection.projection = proj1;
                projection.position = final_proj_position;
                projection.normal = final_proj_normal;

                // We have to calculate the force at this point
                denom = dot(projection.normal, projection.normal);
                c = cross(v3.position - v2.position, final_proj_position - v2.position);
                u = dot(projection.normal, c) / denom;
                c = cross(v1.position - v3.position, final_proj_position - v3.position);
                v = dot(projection.normal, c) / denom;
                if (dot(v1.force,projection.normal)<0) v1force = float3(0,0,0);
                else v1force = v1.force;
                if (dot(v2.force,projection.normal)<0) v2force = float3(0,0,0);
                else v2force = v2.force;
                if (dot(v3.force,projection.normal)<0) v3force = float3(0,0,0);
                else v3force = v3.force;
                projection.external_force = (u * v1force) + (v * v2force) + ((1.0-u-v) * v3force);
                if (dot(projection.external_force,projection.normal)<0) {
                    // We re-program the external force to be that it follows the tangential component of the external force only
                    float3 force_normal_comp = (dot(projection.external_force,-projection.normal)/dot(-projection.normal, -projection.normal)) * -projection.normal;
                    projection.external_force = projection.external_force - force_normal_comp;
                    //projection.external_force = -projection.external_force;
                }
                // We also have to calculate the amount of force exerted by the particle.
                // For now, we just calculate the orthogonal force based on the particle's current force
                // To calculate the force component along the normal vector, we:
                // 1) detect if the particle is within range or is intersecting with the triangle
                // 2) if so, perform the follwing: dot(normal,particle force) / length(normal)
                // since the normal is normalized, it'll just be 1. So we just calcualte dot(normal, particle force)
                //projection.particle_force = dot(-final_proj_normal, particle.force) * (-final_proj_normal);
                
                if (
                    //distfinal <= particleRenderRadius
					distfinal <= 0
                    || dot(final_proj_position - innermostPoint, final_proj_normal) >= 0.0
                ) {
                    projection.particle_force = dot(-final_proj_normal, particle.force) * (-final_proj_normal);
                    if (dot(projection.particle_force,final_proj_normal) > 0.0) projection.particle_force = float3(0,0,0);
                } else {
                    projection.particle_force = float3(0,0,0);
                }
                

                projection.counter = isInTriangle;
                projection.frictionCoefficient = o.frictionCoefficient;
                projection.restitutionCoefficient = o.restitutionCoefficient;

                projection.e1 = edge1;
                projection.e2 = edge2;
                projection.e1_2DN = e1_2DN;
                projection.e2_2DN = e2_2DN;
                projection.e1_3DN = e1_3DN;
                projection.e2_3DN = e2_3DN;
            }

            if (meshobs_found == 0 || distfinal < meshobs_closest_distance) {
                meshobs_found = 1;
                meshobs_closest_distance = distfinal;
                meshobs_closest_point = final_proj_position;
                meshobs_closest_normal = final_proj_normal;
            }
        }
    }
	// The issue is that everything in projection is now in the local space of the obstacle. However... we should be fine
	// Because all we need to do is calculate those in `update Positions` kernel, not here.
    projections[id] = projection;
}
*/

#pragma kernel UpdatePositions
[numthreads(256,1,1)]
void UpdatePositions(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numParticles) return;

    float3 v = velocities[id.x];
    Particle p = particles[id.x];
	//p.position += v * deltaTime;

    Projection projection = obstacleForces[id.x];

    /*
    // Before we do anything else, we do something else first: try to determine if the innermost part of the particle, given the projection, is inside the mesh or not
    float3 a = (pressureForces[id] + viscosityForces[id] + density[id] * g) / density[id];
    v += a * deltaTime;
    */

    // Terminology:
    // p.position = the particle's current position
    // - projection.position = the partlce's closest point on the mesh to consider
    // - innermostPoint = a point on the edge of the particle, calculated using the negative of the normal vector of the mesh component the projection maintained

    // If we have any projectsion to consider and the normal vector is not nonexistent...
    if (projection.counter > 0 && length(projection.normal) > 0.0) {
		float3 n = normalize(mul(localdir_to_world_matrices[projection.obstacle_id],projection.normal));
		float3 projp = mul(localpos_to_world_matrices[projection.obstacle_id],projection.position);
        // calculate the normal. Normalize again if necessary
        // Calculate innermost point following the negative direction of the normal
        float3 innermostPoint = p.position - n * smoothingRadius;
        // Calculate the distance between the particle and the particle's closest point on the mesh
        float distfinal = distance(projp, p.position);
        // If the dot product between the innermost point and particle position and the normal vector is + in sign, then we need to reflect
        if (sign(dot(projp - innermostPoint, n))>0.0) {
            if (length(v)>0.0 && dot(v,n) <= 0.0) {
                // If so, we have to calculate the reflection of the particle, but only if the velocity is not 0 in magnitude and if the velocity is inward

                // This series of equations was derived from that of Carlos Alberto Dutra Fraga Filho.
                // Report: https://doi.org/10.21203/rs.3.rs-3214518/v1
                // The collided, reflected velocity comes in a normal form and a tangential form.
                // Note: to calculate the magnitude of a vector A as a component along another vector B, we use the following formula:
                // dot(A,B)/dot(B,B)
                // However, since B (which is the normal vector) is a normalized normal, the denominator just ends up being 1
                // Therefore, we only need to calculate dot(A,B). To get the magnitude, we get the absolute value of this value
                // The magnitude of the normal component of vel_ref is the same as the magnitude of the normal component of the incoming vector
                float vn = abs(dot(v,-n));
                float3 vtan = v - (-n*vn);
                float vt = length(vtan);
                float3 vrn = n * vn * projection.restitutionCoefficient;
                float3 vrt = vtan * (1.0-projection.frictionCoefficient); 
                v = vrn + vrt;
				float3 projforce = mul(localpos_to_world_matrices[projection.obstacle_id], projection.external_force);
                v += projection.frictionCoefficient * projforce * deltaTime;
                // Now, v is reflected off the surface.
            }

            // move the position to the ideal position and set the position
            if (length(v) > 0.0) v = normalize(v) * clamp(length(v),0.0,30.0);
            velocities[id.x] = v;
            velocity_magnitudes[id.x] = length(v);
            particles[id.x].position = projection.position + n * (smoothingRadius + 0.01);
            return;
        } 
    }

    // Clamp the velocity so that particles don't go haywire
    if (length(v) > 0.0) v = normalize(v) * clamp(length(v),0.0,30.0);
    velocities[id.x] = v;
    velocity_magnitudes[id.x] = length(v);
    particles[id.x].position += v * deltaTime;
}