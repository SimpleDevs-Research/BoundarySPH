// == VARIABLES ==
float gridCellSize;
int3 numCellsPerAxis;
int total_number_of_cells;
float gridScalingX;
float gridScalingY;
float gridScalingZ;

int numParticles;
float radius;
float bulkModulus;

// == STRUCTS ==
struct GridCell {
    int n;
    float3 worldPosition;
    int cellPressure;
};
struct Particle {
    float3 position;            // The world position of the particle
    float3 force;               // The force current experienced by the particle that is caused by pressure and viscosity
    int render;
};

// == BUFFERS ==
RWStructuredBuffer<GridCell> grid;
RWStructuredBuffer<float> bounds;   // What are the limits of this simulation, in world space?
RWStructuredBuffer<Particle> particles;
RWStructuredBuffer<float> density;  // Stores the density of each particle
RWStructuredBuffer<float> pressures;

//RWStructuredBuffer<int> tempParticles;

// == HELPER FUNCTIONTS ==
int3 GetGridXYZIndices(float3 position) {
    return int3(
        floor((position[0] - gridScalingX)/gridCellSize),
        floor((position[1] - gridScalingY)/gridCellSize),
        floor((position[2] - gridScalingZ)/gridCellSize)
    );
}
int GetProjectedGridIndexFromXYZ(int3 xyz) {
    return xyz[0] + (numCellsPerAxis[0] * xyz[1]) + (numCellsPerAxis[0] * numCellsPerAxis[1] * xyz[2]);
}
float3 GetWorldPositionFromXYZ(int3 xyz) {
    return float3(
        bounds[0] + (gridCellSize * 0.5) + (gridCellSize * xyz[0]),
        bounds[1] + (gridCellSize * 0.5) + (gridCellSize * xyz[1]),
        bounds[2] + (gridCellSize * 0.5) + (gridCellSize * xyz[2])
    );
}
int GetProjectedGridIndexFromGivenPosition(float3 position) {
    int3 xyz = GetGridXYZIndices(position);
    return GetProjectedGridIndexFromXYZ(xyz);
}

int IsInBounds(float3 position) {
    if (
        bounds[0] <= position[0] 
        && position[0] <= bounds[3] 
        && bounds[1] <= position[1] 
        && position[1] <= bounds[4] 
        && bounds[2] <= position[2] 
        && position[2] <= bounds[5]
    ) return 1;
    return 0;
}

#pragma kernel ClearGrid
[numthreads(8,8,8)]
void ClearGrid(uint3 id : SV_DispatchThreadID) {
    if (
        id.x >= uint(numCellsPerAxis[0])
        || id.y >= uint(numCellsPerAxis[1])
        || id.z >= uint(numCellsPerAxis[2])
    ) return;

    // Update the grid cell
    int projectedID = GetProjectedGridIndexFromXYZ(id);
    grid[projectedID].n = 0;
    grid[projectedID].cellPressure = 0;
    // We also set the world position of the grid cell here
    grid[projectedID].worldPosition = GetWorldPositionFromXYZ(id);
    // Finally, reset the pressure floats
    pressures[projectedID] = 0.0;
    // return
    return;
}

#pragma kernel UpdatePressures
[numthreads(256,1,1)]
void UpdatePressures(uint id : SV_DispatchThreadID) {
    if (id >= (uint)numParticles) return;
    // Get the grid cell index from the position of the particle
    float3 p = particles[id].position;
    float pressure = bulkModulus * density[id];

    if (IsInBounds(p) == 0) return;

    pressures[id] = pressure;

    float3 lower = float3(
        max(bounds[0], p[0] - radius),
        max(bounds[1], p[1] - radius),
        max(bounds[2], p[2] - radius)
    );
    float3 upper = float3(
        min(bounds[3], p[0] + radius),
        min(bounds[4], p[1] + radius),
        min(bounds[5], p[2] + radius)
    );

    int3 lowerXYZ = GetGridXYZIndices(lower);
    int3 upperXYZ = GetGridXYZIndices(upper);

    int projectedID;
    float w;
    for(int x = lowerXYZ[0]; x <= upperXYZ[0]; x++) {
        for (int y = lowerXYZ[1]; y <= upperXYZ[1]; y++) {
            for(int z = lowerXYZ[2]; z <= upperXYZ[2]; z++) {
                projectedID = GetProjectedGridIndexFromXYZ(int3(x,y,z));
                w = min(1.0,(radius - distance(p,grid[projectedID].worldPosition))/radius);
                if (w > 0) {
                    InterlockedAdd(grid[projectedID].n, 1);
                    InterlockedAdd(grid[projectedID].cellPressure, int(pressure * w * 1024.0)); 
                }
            }
        }
    }

    //int3 xyz = GetGridXYZIndices(p);

    //int projectedID = GetProjectedGridIndexFromGivenPosition(p);
    // We contribute density to our grid cell's pressure
    //InterlockedAdd(grid[projectedID].cellPressure, int(bulkModulus * density[id] * 1024.0)); 
    //InterlockedAdd(grid[projectedID].n, 1);
    //InterlockedAdd(grid[projectedID].cellPressure, int(bulkModulus * density[id] * 1024.0)); 

    //tempParticles[id] = projectedID;
}

#pragma kernel CondensePressures
[numthreads(8,8,8)]
void CondensePressures(uint3 id : SV_DispatchThreadID) {
    if (
        id.x >= uint(numCellsPerAxis[0])
        || id.y >= uint(numCellsPerAxis[1])
        || id.z >= uint(numCellsPerAxis[2])
    ) return;
    int projectedID = GetProjectedGridIndexFromXYZ(id);
    // update the corresponding float in `pressures`
    if (grid[projectedID].n == 0) {
        pressures[projectedID] = 0.0;
    } else {
        pressures[projectedID] = (float(grid[projectedID].cellPressure) / 1024.0);
    }
}
