// == VARIABLES ==
float gridCellSize;
int3 numCellsPerAxis;
int total_number_of_cells;
float gridScalingX;
float gridScalingY;
float gridScalingZ;

int numParticles;
float radius;
float bulkModulus;

int numObstacles;

// == STRUCTS ==
struct GridCell {
    int n;
    float3 worldPosition;
    int cellPressure;
};
struct Particle {
    float3 position;            // The world position of the particle
    float3 force;               // The force current experienced by the particle that is caused by pressure and viscosity
    int render;
};

/// Represents the STATIC properties of an obstacle. This includes the vertex, triangle, and edge indices.
struct ObstacleStatic {
    uint index;                 // Ref. index inside the obstacles arrays.
    uint2 vs;                   // [0] = starting index in the vertices arrays, [1] = the number of vertices.
    uint2 ts;                   // [0] = starting index in the triangles arrays, [1] = the number of triangles.
    uint2 es;                   // [0] = starting index in the edges arrays, [1] = the number of edges.
    float mass;                 // The mass of the obstacle. Considered a "static" variable because mass doesn't change.
    uint has_rb;
    uint has_smr;
};
/// Represents the DYNAMIC properties of an obstacle that change during the update lop.
struct ObstacleDynamic {
    uint index;                  // Ref. index inside the obstacles arrays.
    float3 position;            // The world-space position of the transform.
    float4 rotation;            // The world-space rotation of the transform.
    float3 scale;               // The world-space scale of the transform. Typically via `Transform.LossyScale`.
    float3 lowerBound;          // The lower boundary position of this obstacle's bounding box.
    float3 upperBound;          // The upper boundary position of this obstacle's bounding box.
    float3 centerOfMass;
    float frictionCoefficient;  // The amount of friction the object is meant to exhibit on particles.
    uint checkObstacleBounds;
    uint checkTriangleBounds;
    uint hasChanged;             // A boolean indicator to determine if this obstacle had transformed in some way between the previous and current frame.
};

/// Represents the STATIC properties of each triangle. These values never change after the pre-processing stage
struct TriangleStatic {
    uint obstacleIndex;     // Ref. index to its parent obstacle in the obstacles arrays.
    uint3 vertices;         // v1,v2,v3 - The indices of the three vertices of this triangle, referencing values in the vertices arrays. Organized in order of v1,v2,v3.
    float3 angles;          // v1,v2,v3 - The angles of each vertex. Used as weights in the calculation of the 3D normal vectors for each vertex. Organized in order of v1,v2,v3.
    uint3 edges;            // v1v2,v1v3,v2v3 - The indices of the three edges of this triangle, referencing values in the edges array. Organized in order of v1v2,v1v3,v2v3.
    float3 localCenter;     // The local-space centroid of the triangle.
    float3 localNormal;     // The local endpoint of the 3D normal vector if starting from `localCenter`
};
/// Represents the DYNAMIC properties of each triangle. These values are updated whenever the parent object is transformed between the previous and current frames.
struct TriangleDynamic {
    uint obstacleIndex;     // Ref. index to its parent obstacle in the obstacles arrays.
    float3 center;          // The world-space centroid of the triangle, defined by calculating the average of the world-space positions of each vertex.
    float3 normal;          // The world-space face normal vector of the triangle, calculated as the cross product of two edges v1v2 and v1v3
    float d;                // The signed distance of the plane to the origin (0,0,0). Needed to calculate the projection points onto the plane defined by this triangle.
    uint3 vertices;
    uint3 edges;
    float3 v1v2n;           // The world-space 2D normal vector of the v1v2 edge.
    float3 v1v3n;           // The world-space 2D normal vector of the v1v3 edge.
    float3 v2v3n;           // The world-space 2D normal vector of the v2v3 edge.
    float3 lowerBound;      // The lower boundary position of this triangle's bounding box.
    float3 upperBound;      // The upper boundary position of this triangle's bounding box.
};

/// Represents the DYNAMIC properties of each vertex. These values have to be updated if the parent obstacle has been transformed between the previous and current frames.
struct VertexDynamic {
    uint obstacleIndex;         // Ref. index to its parent obstacle in the obstacles arrays.
    float3 position;            // The current world-space position of this vertex.
    float3 normal;              // The current world-space, 3D normal vector of this vertex.
    float3 force;               // The calculated force based on the current velocity and previous velocity, which is F=m*(v/t)
};


// == BUFFERS ==
RWStructuredBuffer<GridCell> grid;
RWStructuredBuffer<float> bounds;   // What are the limits of this simulation, in world space?
RWStructuredBuffer<Particle> particles;
RWStructuredBuffer<float> density;  // Stores the density of each particle
RWStructuredBuffer<float> pressures;

StructuredBuffer<ObstacleStatic> obstacles_static;
StructuredBuffer<ObstacleDynamic> obstacles_dynamic;
StructuredBuffer<TriangleStatic> triangles_static;
StructuredBuffer<TriangleDynamic> triangles_dynamic;
StructuredBuffer<VertexDynamic> vertices_dynamic;
StructuredBuffer<float3> edges_dynamic;

RWStructuredBuffer<int3> translational_pressure_forces;

// == HELPER FUNCTIONTS ==
int3 GetGridXYZIndices(float3 position) {
    return int3(
        floor((position[0] - gridScalingX)/gridCellSize),
        floor((position[1] - gridScalingY)/gridCellSize),
        floor((position[2] - gridScalingZ)/gridCellSize)
    );
}
int GetProjectedGridIndexFromXYZ(int3 xyz) {
    return xyz[0] + (numCellsPerAxis[0] * xyz[1]) + (numCellsPerAxis[0] * numCellsPerAxis[1] * xyz[2]);
}
float3 GetWorldPositionFromXYZ(int3 xyz) {
    return float3(
        bounds[0] + (gridCellSize * 0.5) + (gridCellSize * xyz[0]),
        bounds[1] + (gridCellSize * 0.5) + (gridCellSize * xyz[1]),
        bounds[2] + (gridCellSize * 0.5) + (gridCellSize * xyz[2])
    );
}
int GetProjectedGridIndexFromGivenPosition(float3 position) {
    int3 xyz = GetGridXYZIndices(position);
    return GetProjectedGridIndexFromXYZ(xyz);
}

int IsInBounds(float3 position) {
    if (
        bounds[0] <= position[0] 
        && position[0] <= bounds[3] 
        && bounds[1] <= position[1] 
        && position[1] <= bounds[4] 
        && bounds[2] <= position[2] 
        && position[2] <= bounds[5]
    ) return 1;
    return 0;
}

int IsInBounds2(float3 position, float3 lowerBounds, float3 upperBounds) {
    if (
        lowerBounds[0] <= position[0] && position[0] <= upperBounds[0]
        && lowerBounds[1] <= position[1] && position[1] <= upperBounds[1] 
        && lowerBounds[2] <= position[2] && position[2] <= upperBounds[2]    
    ) return 1;
    return 0;
}

int CheckVoroniRegions(
        float3 proj,                    // the projection of 3D point onto the 2D plane
        float3 v, float3 vN,            // the comparison vertex of the triangle + its normal
        float3 e1, float3 e2,           // The two edges connected to v1
        float3 e1_2DN, float3 e2_2DN,   // The 2D normals of the two edges
        float3 e1_3DN, float3 e2_3DN,   // The 3D normals of the two edges
        float3 tri_N,                    // The normal of the triangle itself
        float threshold,                // The threshold value for edge comparison
        out float3 closestPoint,
        out float3 closestNormal
) {
    // Determine vector from vertex to position
    float3 v_to_p = proj - v;
    
    // Now, the position is closest to the vertex if the dot(edge1 , v_to_p) <= 0 AND dot(edge2, v_to_p) <= 0
    float d1 = dot(e1, v_to_p);
    float d2 = dot(e2, v_to_p);
    if (d1 <= 0 && d2 <= 0) {
        closestPoint = v;
        closestNormal = vN;
        // We need to check if the point is actually the vertex 
        //if (d1 == 0 && d2 == 0) return 1;
        //return 0;
        return 1;
    }
    
    // At this point, we need to check if position is closer to edge1 or edge2. This is via dot product comparison
    // We introduce a "threshold" because float points are finicky and there's a margin for error w.r.t. if the projection is exactly on the line
    float d3 = dot(e1_2DN, v_to_p);
    if (d3 >= threshold) {
        closestPoint = v+ e1 * abs((d1 / dot(e1, e1)));
        closestNormal = e1_3DN;
        //if (d3 == threshold) return 1;
        //return 0;
        return 2;
    }
    float d4 = dot(e2_2DN, v_to_p);
    if (d4 >= threshold) {
        closestPoint = v + e2 * abs((d2 / dot(e2, e2)));
        closestNormal = e2_3DN;
        //if (d4 == threshold) return 1;
        //return 0;
        return 2;
    }

    // At this point, the point is inside the triangle. No need to reproject
    closestPoint = proj;
    closestNormal = tri_N;
    //return 1;
    return 3;
}

#pragma kernel ClearGrid
[numthreads(8,8,8)]
void ClearGrid(uint3 id : SV_DispatchThreadID) {
    if (
        id.x >= uint(numCellsPerAxis[0])
        || id.y >= uint(numCellsPerAxis[1])
        || id.z >= uint(numCellsPerAxis[2])
    ) return;

    // Update the grid cell
    int projectedID = GetProjectedGridIndexFromXYZ(id);
    grid[projectedID].n = 0;
    grid[projectedID].cellPressure = 0;
    // We also set the world position of the grid cell here
    grid[projectedID].worldPosition = GetWorldPositionFromXYZ(id);
    // Finally, reset the pressure floats
    pressures[projectedID] = 0.0;
    // return
    return;
}

#pragma kernel ClearAppliedPressures
[numthreads(8,1,1)]
void ClearAppliedPressures(uint id : SV_DispatchThreadID) {
    if (id >= (uint)numObstacles) return;
    translational_pressure_forces[id] = int3(0,0,0);
}

#pragma kernel UpdatePressures
[numthreads(256,1,1)]
void UpdatePressures(uint id : SV_DispatchThreadID) {
    if (id >= (uint)numParticles) return;
    // Get the grid cell index from the position of the particle
    float3 p = particles[id].position;
    float pressure = pressures[id];

    if (IsInBounds(p) == 0) return;

    float3 lower = float3(
        max(bounds[0], p[0] - radius),
        max(bounds[1], p[1] - radius),
        max(bounds[2], p[2] - radius)
    );
    float3 upper = float3(
        min(bounds[3], p[0] + radius),
        min(bounds[4], p[1] + radius),
        min(bounds[5], p[2] + radius)
    );

    int3 lowerXYZ = GetGridXYZIndices(lower);
    int3 upperXYZ = GetGridXYZIndices(upper);

    int projectedID;
    float w;
    for(int x = lowerXYZ[0]; x <= upperXYZ[0]; x++) {
        for (int y = lowerXYZ[1]; y <= upperXYZ[1]; y++) {
            for(int z = lowerXYZ[2]; z <= upperXYZ[2]; z++) {
                projectedID = GetProjectedGridIndexFromXYZ(int3(x,y,z));
                w = min(1.0,(radius - distance(p,grid[projectedID].worldPosition))/radius);
                if (w > 0) {
                    InterlockedAdd(grid[projectedID].n, 1);
                    InterlockedAdd(grid[projectedID].cellPressure, int(pressure * w * 1024.0)); 
                }
            }
        }
    }

    //int3 xyz = GetGridXYZIndices(p);

    //int projectedID = GetProjectedGridIndexFromGivenPosition(p);
    // We contribute density to our grid cell's pressure
    //InterlockedAdd(grid[projectedID].cellPressure, int(bulkModulus * density[id] * 1024.0)); 
    //InterlockedAdd(grid[projectedID].n, 1);
    //InterlockedAdd(grid[projectedID].cellPressure, int(bulkModulus * density[id] * 1024.0)); 

    //tempParticles[id] = projectedID;
}

#pragma kernel CondensePressures
[numthreads(8,8,8)]
void CondensePressures(uint3 id : SV_DispatchThreadID) {
    if (
        id.x >= uint(numCellsPerAxis[0])
        || id.y >= uint(numCellsPerAxis[1])
        || id.z >= uint(numCellsPerAxis[2])
    ) return;
    int projectedID = GetProjectedGridIndexFromXYZ(id);
    // update the corresponding float in `pressures`
    if (grid[projectedID].n == 0) {
        pressures[projectedID] = 0.0;
    } else {
        pressures[projectedID] = (float(grid[projectedID].cellPressure) / 1024.0);
    }
}

#pragma kernel ApplyPressures
[numthreads(8,8,8)]
void ApplyPressures(uint3 id : SV_DispatchThreadID) {
    if (
        id.x >= uint(numCellsPerAxis[0])
        || id.y >= uint(numCellsPerAxis[1])
        || id.z >= uint(numCellsPerAxis[2])
    ) return;
    int projectedID = GetProjectedGridIndexFromXYZ(id);

    // We can get the cell based on id
    GridCell c = grid[projectedID];

    // We now loop through all obstacles
    for (int oi = 0; oi < numObstacles; oi++) {
        // We also grab the current obstacle from id
        ObstacleDynamic o_dynamic = obstacles_dynamic[oi];

        // We end early if the grid cell's world position doesn't even fit inside the boundaries of the obstacle
        if (IsInBounds2(c.worldPosition, o_dynamic.lowerBound, o_dynamic.upperBound) == 0) return;

        // We also grab the static properties of the obstacle from id
        ObstacleStatic o_static = obstacles_static[oi];

        // We initialize some other variables
        TriangleDynamic tri_dynamic;
        VertexDynamic v1, v2, v3;

        // We need to iterate through all triangles of this obstacle
        // The end goal is to find the closest point
        int found = 0;
        float3 closest_point = c.worldPosition;
        float closest_distance = 0.0;
        float3 closest_normal = float3(0,0,0);
        for(uint i = o_static.ts[0]; i < o_static.ts[0] + o_static.ts[1]; i++) {

            // We grab the dynamic properties of the current triangle
            tri_dynamic = triangles_dynamic[i];

            // Check if the grid cell is inside the triangle's boundaries
            //if (IsInBounds(c.worldPosition, tri_dynamic.lowerBound, tri_dynamic.upperBound) == 0) continue;

            // More references
            v1 = vertices_dynamic[o_static.vs[0] + tri_dynamic.vertices[0]];
            v2 = vertices_dynamic[o_static.vs[0] + tri_dynamic.vertices[1]];
            v3 = vertices_dynamic[o_static.vs[0] + tri_dynamic.vertices[2]];

            // At this point, we need to project the grid cell's position onto the plane defined by this triangle.
            // To calculate this projection, we grab the normal vector of the triangle and use that as our direction
            // Normally, we need to check if the vector from the particle's position to the centroid of the plane is parallal to the normal vector direction...
            //   ... however, in this case, we don't have to do that. This is because the direction we're using to project the particle position will always be orthogonal to the plane
            float3 dir = normalize(sign(dot(tri_dynamic.normal, tri_dynamic.center - c.worldPosition)) * tri_dynamic.normal);
            // We need to project the point onto the plane formed by this triangle
            float dist_from_point_to_plane = -(dot(tri_dynamic.normal, c.worldPosition) + tri_dynamic.d) / dot(tri_dynamic.normal, dir);
            float3 proj1 = c.worldPosition + dist_from_point_to_plane * dir;

            // We now need to determine the arguments we will be sending to our Voronoi check system
            float3 closestVertexPosition = v1.position;
            float3 closestVertexNormal = v1.normal;
            float3 edge1 = v2.position - v1.position;
            float3 edge2 = v3.position - v1.position;
            float3 e1_2DN = tri_dynamic.v1v2n;
            float3 e2_2DN = tri_dynamic.v1v3n;
            float3 e1_3DN = edges_dynamic[o_static.es[0] + tri_dynamic.edges[0]];
            float3 e2_3DN = edges_dynamic[o_static.es[0] + tri_dynamic.edges[1]];
            float denom, u, v, distfinal;
            float3 innermostPoint, v1force, v2force, v3force;
                
            if (distance(c.worldPosition, v2.position) < distance(c.worldPosition, closestVertexPosition)) {
                closestVertexPosition = v2.position;
                closestVertexNormal = v2.normal;
                edge1 = v1.position - v2.position;
                edge2 = v3.position - v2.position;
                e1_2DN = tri_dynamic.v1v2n;
                e2_2DN = tri_dynamic.v2v3n;
                e1_3DN = edges_dynamic[o_static.es[0] + tri_dynamic.edges[0]];
                e2_3DN = edges_dynamic[o_static.es[0] + tri_dynamic.edges[2]];
            }
            if (distance(c.worldPosition, v3.position) < distance(c.worldPosition, closestVertexPosition)) {
                closestVertexPosition = v3.position;
                closestVertexNormal = v3.normal;
                edge1 = v1.position - v3.position;
                edge2 = v2.position - v3.position;
                e1_2DN = tri_dynamic.v1v3n;
                e2_2DN = tri_dynamic.v2v3n;
                e1_3DN = edges_dynamic[o_static.es[0] + tri_dynamic.edges[1]];
                e2_3DN = edges_dynamic[o_static.es[0] + tri_dynamic.edges[2]];
            }

            // Finally, we get the closest position on the obstacle
            float3 final_proj_position;
            float3 final_proj_normal;
            int isInTriangle = CheckVoroniRegions(
                proj1,                          // The projection of the particle position onto the plane
                closestVertexPosition, closestVertexNormal,   // The closest vertex position + its 3D normal
                edge1, edge2,                   // The two edges connected to the closest vertex
                normalize(e1_2DN), normalize(e2_2DN),                 // The 2D normals of the two connected edges
                normalize(e1_3DN), normalize(e2_3DN),                 // The 3D normals of the two connected edges
                normalize(tri_dynamic.normal),             // The triangle normal
                0.05,                            // The threshold for overlap
                final_proj_position,        // reference to the projection position
                final_proj_normal           // reference the projection normal
            );

            // We need to compare `final_proj_position` and `closest_point`
            float current_distance = distance(final_proj_position, c.worldPosition);
            if (found == 0 || current_distance < closest_distance) {
                // We have found a potential closest point
                found = 1;
                closest_point = final_proj_position;
                closest_normal = final_proj_normal;
                closest_distance = closest_distance;
            } 
        }

        // Once we have our closest point, we need to check the following:
        // 1. ... Did we actually find a closetst point to begin with?
        // 2. Is the closest point within the smoothing kernel radius range of our grid cell?
        // 3. Is the grid cell "OUTSIDE" or "INSIDE" the obstacle, knowing the closest point?
        // We can do that by determining the sign of the dot product between the normal and the direction from the closst point to our grid cell's position, as well as the magnitude of that latter vector
        if (found == 0) return;
        
        float3 closest_to_proj = c.worldPosition - closest_point;
        float s = sign(dot(closest_to_proj,closest_normal));
        if (length(closest_to_proj) <= radius && s >= 0.0) {
            // At this point, we merely have to apply the pressure value of this grid cell in the direction towards the closest point
            float3 pressure_vector = -normalize(closest_to_proj) * pressures[projectedID];
            InterlockedAdd(translational_pressure_forces[oi][0], (int)(pressure_vector[0] * 1024.0));
            InterlockedAdd(translational_pressure_forces[oi][1], (int)(pressure_vector[1] * 1024.0));
            InterlockedAdd(translational_pressure_forces[oi][2], (int)(pressure_vector[2] * 1024.0));
        }
    }
}
